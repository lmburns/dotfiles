'\" t
.\"     Title: picom
.\"    Author: [see the "AUTHOR(S)" section]
.\" Generator: Asciidoctor 2.0.16
.\"      Date: 2021-10-09
.\"    Manual: User Commands
.\"    Source: picom
.\"  Language: English
.\"
.TH "PICOM" "1" "2021-10-09" "picom" "User Commands"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
picom \- a compositor for X11
.SH "SYNOPSIS"
.sp
\fBpicom\fP [\fIOPTIONS\fP]
.SH "DESCRIPTION"
.sp
picom is a compositor based on Dana Jansens\*(Aq version of xcompmgr (which itself was written by Keith Packard). It includes some improvements over the original xcompmgr, like window frame opacity and inactive window transparency.
.SH "OPTIONS"
.sp
\fB\-h\fP, \fB\-\-help\fP
.RS 4
Get the usage text embedded in program code, which may be more up\-to\-date than this man page.
.RE
.sp
\fB\-r\fP, \fB\-\-shadow\-radius\fP=\fIRADIUS\fP
.RS 4
The blur radius for shadows, in pixels. (defaults to 12)
.RE
.sp
\fB\-o\fP, \fB\-\-shadow\-opacity\fP=\fIOPACITY\fP
.RS 4
The opacity of shadows. (0.0 \- 1.0, defaults to 0.75)
.RE
.sp
\fB\-l\fP, \fB\-\-shadow\-offset\-x\fP=\fIOFFSET\fP
.RS 4
The left offset for shadows, in pixels. (defaults to \-15)
.RE
.sp
\fB\-t\fP, \fB\-\-shadow\-offset\-y\fP=\fIOFFSET\fP
.RS 4
The top offset for shadows, in pixels. (defaults to \-15)
.RE
.sp
\fB\-I\fP, \fB\-\-fade\-in\-step\fP=\fIOPACITY_STEP\fP
.RS 4
Opacity change between steps while fading in. (0.01 \- 1.0, defaults to 0.028)
.RE
.sp
\fB\-O\fP, \fB\-\-fade\-out\-step\fP=\fIOPACITY_STEP\fP
.RS 4
Opacity change between steps while fading out. (0.01 \- 1.0, defaults to 0.03)
.RE
.sp
\fB\-D\fP, \fB\-\-fade\-delta\fP=\fIMILLISECONDS\fP
.RS 4
The time between steps in fade step, in milliseconds. (> 0, defaults to 10)
.RE
.sp
\fB\-m\fP, \fB\-\-menu\-opacity\fP=\fIOPACITY\fP
.RS 4
Default opacity for dropdown menus and popup menus. (0.0 \- 1.0, defaults to 1.0)
.RE
.sp
\fB\-c\fP, \fB\-\-shadow\fP
.RS 4
Enabled client\-side shadows on windows. Note desktop windows (windows with \fI_NET_WM_WINDOW_TYPE_DESKTOP\fP) never get shadow, unless explicitly requested using the wintypes option.
.RE
.sp
\fB\-f\fP, \fB\-\-fading\fP
.RS 4
Fade windows in/out when opening/closing and when opacity changes, unless \fB\-\-no\-fading\-openclose\fP is used.
.RE
.sp
\fB\-F\fP
.RS 4
Equals to \fB\-f\fP. Deprecated.
.RE
.sp
\fB\-i\fP, \fB\-\-inactive\-opacity\fP=\fIOPACITY\fP
.RS 4
Opacity of inactive windows. (0.1 \- 1.0, defaults to 1.0)
.RE
.sp
\fB\-e\fP, \fB\-\-frame\-opacity\fP=\fIOPACITY\fP
.RS 4
Opacity of window titlebars and borders. (0.1 \- 1.0, disabled by default)
.RE
.sp
\fB\-b\fP, \fB\-\-daemon\fP
.RS 4
Daemonize process. Fork to background after initialization. This option can only be set from the command line, setting this in the configuration file will have no effect.
.RE
.sp
\fB\-\-log\-level\fP
.RS 4
Set the log level. Possible values are "TRACE", "DEBUG", "INFO", "WARN", "ERROR", in increasing level of importance. Case doesn\(cqt matter. If using the "TRACE" log level, it\(cqs better to log into a file using \fB\-\-log\-file\fP, since it can generate a huge stream of logs.
.RE
.sp
\fB\-\-log\-file\fP
.RS 4
Set the log file. If \fB\-\-log\-file\fP is never specified, logs will be written to stderr. Otherwise, logs will to written to the given file, though some of the early logs might still be written to the stderr. When setting this option from the config file, it is recommended to use an absolute path.
.RE
.sp
\fB\-\-experimental\-backends\fP
.RS 4
Use the new, reimplemented version of the backends. The new backends are HIGHLY UNSTABLE at this point, you have been warned. This option is not available in the config file.
.RE
.sp
\fB\-\-show\-all\-xerrors\fP
.RS 4
Show all X errors (for debugging).
.RE
.sp
\fB\-\-config\fP \fIPATH\fP
.RS 4
Look for configuration file at the path. See \fBCONFIGURATION FILES\fP section below for where picom looks for a configuration file by default. Use \f(CR/dev/null\fP to avoid loading configuration file.
.RE
.sp
\fB\-\-write\-pid\-path\fP \fIPATH\fP
.RS 4
Write process ID to a file. it is recommended to use an absolute path.
.RE
.sp
\fB\-\-shadow\-color\fP \fISTRING\fP
.RS 4
Color of shadow, as a hex string (\fI#000000\fP)
.RE
.sp
\fB\-\-shadow\-red\fP \fIVALUE\fP
.RS 4
Red color value of shadow (0.0 \- 1.0, defaults to 0).
.RE
.sp
\fB\-\-shadow\-green\fP \fIVALUE\fP
.RS 4
Green color value of shadow (0.0 \- 1.0, defaults to 0).
.RE
.sp
\fB\-\-shadow\-blue\fP \fIVALUE\fP
.RS 4
Blue color value of shadow (0.0 \- 1.0, defaults to 0).
.RE
.sp
\fB\-\-inactive\-opacity\-override\fP
.RS 4
Let inactive opacity set by \fB\-i\fP override the \fI_NET_WM_OPACITY\fP values of windows.
.RE
.sp
\fB\-\-active\-opacity\fP \fIOPACITY\fP
.RS 4
Default opacity for active windows. (0.0 \- 1.0, defaults to 1.0)
.RE
.sp
\fB\-\-inactive\-dim\fP \fIVALUE\fP
.RS 4
Dim inactive windows. (0.0 \- 1.0, defaults to 0.0)
.RE
.sp
\fB\-\-corner\-radius\fP \fIVALUE\fP
.RS 4
Sets the radius of rounded window corners. When > 0, the compositor will round the corners of windows. Does not interact well with \fB\-\-transparent\-clipping\fP. (defaults to 0).
.RE
.sp
\fB\-\-rounded\-corners\-exclude\fP \fICONDITION\fP
.RS 4
Exclude conditions for rounded corners.
.RE
.sp
\fB\-\-mark\-wmwin\-focused\fP
.RS 4
Try to detect WM windows (a non\-override\-redirect window with no child that has \fIWM_STATE\fP) and mark them as active.
.RE
.sp
\fB\-\-mark\-ovredir\-focused\fP
.RS 4
Mark override\-redirect windows that doesn\(cqt have a child window with \fIWM_STATE\fP focused.
.RE
.sp
\fB\-\-no\-fading\-openclose\fP
.RS 4
Do not fade on window open/close.
.RE
.sp
\fB\-\-no\-fading\-destroyed\-argb\fP
.RS 4
Do not fade destroyed ARGB windows with WM frame. Workaround of bugs in Openbox, Fluxbox, etc.
.RE
.sp
\fB\-\-shadow\-ignore\-shaped\fP
.RS 4
Do not paint shadows on shaped windows. Note shaped windows here means windows setting its shape through X Shape extension. Those using ARGB background is beyond our control. Deprecated, use \f(CR\-\-shadow\-exclude \*(Aqbounding_shaped\*(Aq\fP or \f(CR\-\-shadow\-exclude \*(Aqbounding_shaped && !rounded_corners\*(Aq\fP instead.
.RE
.sp
\fB\-\-detect\-rounded\-corners\fP
.RS 4
Try to detect windows with rounded corners and don\(cqt consider them shaped windows. The accuracy is not very high, unfortunately.
.RE
.sp
\fB\-\-detect\-client\-opacity\fP
.RS 4
Detect \fI_NET_WM_OPACITY\fP on client windows, useful for window managers not passing \fI_NET_WM_OPACITY\fP of client windows to frame windows.
.RE
.sp
\fB\-\-refresh\-rate\fP \fIREFRESH_RATE\fP
.RS 4
Specify refresh rate of the screen. If not specified or 0, picom will try detecting this with X RandR extension.
.RE
.sp
\fB\-\-vsync\fP, \fB\-\-no\-vsync\fP
.RS 4
Enable/disable VSync.
.RE
.sp
\fB\-\-use\-ewmh\-active\-win\fP
.RS 4
Use EWMH \fI_NET_ACTIVE_WINDOW\fP to determine currently focused window, rather than listening to \fIFocusIn\fP/\fIFocusOut\fP event. Might have more accuracy, provided that the WM supports it.
.RE
.sp
\fB\-\-unredir\-if\-possible\fP
.RS 4
Unredirect all windows if a full\-screen opaque window is detected, to maximize performance for full\-screen windows. Known to cause flickering when redirecting/unredirecting windows.
.RE
.sp
\fB\-\-unredir\-if\-possible\-delay\fP \fIMILLISECONDS\fP
.RS 4
Delay before unredirecting the window, in milliseconds. Defaults to 0.
.RE
.sp
\fB\-\-unredir\-if\-possible\-exclude\fP \fICONDITION\fP
.RS 4
Conditions of windows that shouldn\(cqt be considered full\-screen for unredirecting screen.
.RE
.sp
\fB\-\-shadow\-exclude\fP \fICONDITION\fP
.RS 4
Specify a list of conditions of windows that should have no shadow.
.RE
.sp
\fB\-\-clip\-shadow\-above\fP \fICONDITION\fP
.RS 4
Specify a list of conditions of windows that should have no shadow painted over, such as a dock window.
.RE
.sp
\fB\-\-fade\-exclude\fP \fICONDITION\fP
.RS 4
Specify a list of conditions of windows that should not be faded.
.RE
.sp
\fB\-\-focus\-exclude\fP \fICONDITION\fP
.RS 4
Specify a list of conditions of windows that should always be considered focused.
.RE
.sp
\fB\-\-inactive\-dim\-fixed\fP
.RS 4
Use fixed inactive dim value, instead of adjusting according to window opacity.
.RE
.sp
\fB\-\-detect\-transient\fP
.RS 4
Use \fIWM_TRANSIENT_FOR\fP to group windows, and consider windows in the same group focused at the same time.
.RE
.sp
\fB\-\-detect\-client\-leader\fP
.RS 4
Use \fIWM_CLIENT_LEADER\fP to group windows, and consider windows in the same group focused at the same time. This usually means windows from the same application will be considered focused or unfocused at the same time.\fIWM_TRANSIENT_FOR\fP has higher priority if \fB\-\-detect\-transient\fP is enabled, too.
.RE
.sp
\fB\-\-blur\-method\fP, \fB\-\-blur\-size\fP, \fB\-\-blur\-deviation\fP, \fB\-\-blur\-strength\fP
.RS 4
Parameters for background blurring, see the \fBBLUR\fP section for more information.
.RE
.sp
\fB\-\-blur\-background\fP
.RS 4
Blur background of semi\-transparent / ARGB windows. Bad in performance, with driver\-dependent behavior. The name of the switch may change without prior notifications.
.RE
.sp
\fB\-\-blur\-background\-frame\fP
.RS 4
Blur background of windows when the window frame is not opaque.  Implies \fB\-\-blur\-background\fP. Bad in performance, with driver\-dependent behavior. The name may change.
.RE
.sp
\fB\-\-blur\-background\-fixed\fP
.RS 4
Use fixed blur strength rather than adjusting according to window opacity.
.RE
.sp
\fB\-\-blur\-kern\fP \fIMATRIX\fP
.RS 4
Specify the blur convolution kernel, with the following format:
.sp
.if n .RS 4
.nf
.fam C
WIDTH,HEIGHT,ELE1,ELE2,ELE3,ELE4,ELE5...
.fam
.fi
.if n .RE
.sp
In other words, the matrix is formatted as a list of comma separated numbers. The first two numbers must be integers, which specify the width and height of the matrix. They must be odd numbers. Then, the following \fIwidth * height \- 1\fP numbers specifies the numbers in the matrix, row by row, excluding the center element.
.sp
The elements are finite floating point numbers. The decimal pointer has to be \fI.\fP (a period), scientific notation is not supported.
.sp
The element in the center will either be 1.0 or varying based on opacity, depending on whether you have \fB\-\-blur\-background\-fixed\fP. Yet the automatic adjustment of blur factor may not work well with a custom blur kernel.
.sp
A 7x7 Gaussian blur kernel (sigma = 0.84089642) looks like:
.sp
.if n .RS 4
.nf
.fam C
\-\-blur\-kern \*(Aq7,7,0.000003,0.000102,0.000849,0.001723,0.000849,0.000102,0.000003,0.000102,0.003494,0.029143,0.059106,0.029143,0.003494,0.000102,0.000849,0.029143,0.243117,0.493069,0.243117,0.029143,0.000849,0.001723,0.059106,0.493069,0.493069,0.059106,0.001723,0.000849,0.029143,0.243117,0.493069,0.243117,0.029143,0.000849,0.000102,0.003494,0.029143,0.059106,0.029143,0.003494,0.000102,0.000003,0.000102,0.000849,0.001723,0.000849,0.000102,0.000003\*(Aq
.fam
.fi
.if n .RE
.sp
May also be one of the predefined kernels: \f(CR3x3box\fP (default), \f(CR5x5box\fP, \f(CR7x7box\fP, \f(CR3x3gaussian\fP, \f(CR5x5gaussian\fP, \f(CR7x7gaussian\fP, \f(CR9x9gaussian\fP, \f(CR11x11gaussian\fP. All Gaussian kernels are generated with sigma = 0.84089642 . If you find yourself needing to generate custom blur kernels, you might want to try the new blur configuration supported by the experimental backends (See \fBBLUR\fP and \fB\-\-experimental\-backends\fP).
.RE
.sp
\fB\-\-blur\-background\-exclude\fP \fICONDITION\fP
.RS 4
Exclude conditions for background blur.
.RE
.sp
\fB\-\-resize\-damage\fP \fIINTEGER\fP
.RS 4
Resize damaged region by a specific number of pixels. A positive value enlarges it while a negative one shrinks it. If the value is positive, those additional pixels will not be actually painted to screen, only used in blur calculation, and such. (Due to technical limitations, with \fB\-\-use\-damage\fP, those pixels will still be incorrectly painted to screen.) Primarily used to fix the line corruption issues of blur, in which case you should use the blur radius value here (e.g. with a 3x3 kernel, you should use \f(CR\-\-resize\-damage 1\fP, with a 5x5 one you use \f(CR\-\-resize\-damage 2\fP, and so on). May or may not work with \fB\-\-glx\-no\-stencil\fP. Shrinking doesn\(cqt function correctly.
.RE
.sp
\fB\-\-invert\-color\-include\fP \fICONDITION\fP
.RS 4
Specify a list of conditions of windows that should be painted with inverted color. Resource\-hogging, and is not well tested.
.RE
.sp
\fB\-\-opacity\-rule\fP \fIOPACITY\fP:\*(AqCONDITION\*(Aq
.RS 4
Specify a list of opacity rules, in the format \f(CRPERCENT:PATTERN\fP, like \f(CR50:name *= "Firefox"\fP. picom\-trans is recommended over this. Note we don\(cqt make any guarantee about possible conflicts with other programs that set \fI_NET_WM_WINDOW_OPACITY\fP on frame or client windows.
.RE
.sp
\fB\-\-shadow\-exclude\-reg\fP \fIGEOMETRY\fP
.RS 4
Specify a X geometry that describes the region in which shadow should not be painted in, such as a dock window region.  Use \f(CR\-\-shadow\-exclude\-reg x10+0\-0\fP, for example, if the 10 pixels on the bottom of the screen should not have shadows painted on.
.RE
.sp
\fB\-\-xinerama\-shadow\-crop\fP
.RS 4
Crop shadow of a window fully on a particular Xinerama screen to the screen.
.RE
.sp
\fB\-\-backend\fP \fIBACKEND\fP
.RS 4
Specify the backend to use: \f(CRxrender\fP, \f(CRglx\fP, or \f(CRxr_glx_hybrid\fP. \f(CRxrender\fP is the default one.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRxrender\fP backend performs all rendering operations with X Render extension. It is what \f(CRxcompmgr\fP uses, and is generally a safe fallback when you encounter rendering artifacts or instability.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRglx\fP (OpenGL) backend performs all rendering operations with OpenGL. It is more friendly to some VSync methods, and has significantly superior performance on color inversion (\fB\-\-invert\-color\-include\fP) or blur (\fB\-\-blur\-background\fP). It requires proper OpenGL 2.0 support from your driver and hardware. You may wish to look at the GLX performance optimization options below. \fB\-\-xrender\-sync\-fence\fP might be needed on some systems to avoid delay in changes of screen contents.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRxr_glx_hybrid\fP backend renders the updated screen contents with X Render and presents it on the screen with GLX. It attempts to address the rendering issues some users encountered with GLX backend and enables the better VSync of GLX backends. \fB\-\-vsync\-use\-glfinish\fP might fix some rendering issues with this backend.
.RE
.RE
.sp
\fB\-\-glx\-no\-stencil\fP
.RS 4
GLX backend: Avoid using stencil buffer, useful if you don\(cqt have a stencil buffer. Might cause incorrect opacity when rendering transparent content (but never practically happened) and may not work with \fB\-\-blur\-background\fP. My tests show a 15% performance boost. Recommended.
.RE
.sp
\fB\-\-glx\-no\-rebind\-pixmap\fP
.RS 4
GLX backend: Avoid rebinding pixmap on window damage. Probably could improve performance on rapid window content changes, but is known to break things on some drivers (LLVMpipe, xf86\-video\-intel, etc.). Recommended if it works.
.RE
.sp
\fB\-\-no\-use\-damage\fP
.RS 4
Disable the use of damage information. This cause the whole screen to be redrawn everytime, instead of the part of the screen has actually changed. Potentially degrades the performance, but might fix some artifacts.
.RE
.sp
\fB\-\-xrender\-sync\-fence\fP
.RS 4
Use X Sync fence to sync clients\*(Aq draw calls, to make sure all draw calls are finished before picom starts drawing. Needed on nvidia\-drivers with GLX backend for some users.
.RE
.sp
\fB\-\-glx\-fshader\-win\fP \fISHADER\fP
.RS 4
GLX backend: Use specified GLSL fragment shader for rendering window contents. See \f(CRcompton\-default\-fshader\-win.glsl\fP and \f(CRcompton\-fake\-transparency\-fshader\-win.glsl\fP in the source tree for examples.
.RE
.sp
\fB\-\-force\-win\-blend\fP
.RS 4
Force all windows to be painted with blending. Useful if you have a \fB\-\-glx\-fshader\-win\fP that could turn opaque pixels transparent.
.RE
.sp
\fB\-\-dbus\fP
.RS 4
Enable remote control via D\-Bus. See the \fBD\-BUS API\fP section below for more details.
.RE
.sp
\fB\-\-benchmark\fP \fICYCLES\fP
.RS 4
Benchmark mode. Repeatedly paint until reaching the specified cycles.
.RE
.sp
\fB\-\-benchmark\-wid\fP \fIWINDOW_ID\fP
.RS 4
Specify window ID to repaint in benchmark mode. If omitted or is 0, the whole screen is repainted.
.RE
.sp
\fB\-\-no\-ewmh\-fullscreen\fP
.RS 4
Do not use EWMH to detect fullscreen windows. Reverts to checking if a window is fullscreen based only on its size and coordinates.
.RE
.sp
\fB\-\-max\-brightness\fP
.RS 4
Dimming bright windows so their brightness doesn\(cqt exceed this set value. Brightness of a window is estimated by averaging all pixels in the window, so this could comes with a performance hit. Setting this to 1.0 disables this behaviour. Requires \fB\-\-use\-damage\fP to be disabled. (default: 1.0)
.RE
.sp
\fB\-\-transparent\-clipping\fP
.RS 4
Make transparent windows clip other windows like non\-transparent windows do, instead of blending on top of them.
.RE
.SH "FORMAT OF CONDITIONS"
.sp
Some options accept a condition string to match certain windows. A condition string is formed by one or more conditions, joined by logical operators.
.sp
A condition with "exists" operator looks like this:
.sp
.if n .RS 4
.nf
.fam C
<NEGATION> <TARGET> <CLIENT/FRAME> [<INDEX>] : <FORMAT> <TYPE>
.fam
.fi
.if n .RE
.sp
With equals operator it looks like:
.sp
.if n .RS 4
.nf
.fam C
<NEGATION> <TARGET> <CLIENT/FRAME> [<INDEX>] : <FORMAT> <TYPE> <NEGATION> <OP QUALIFIER> <MATCH TYPE> = <PATTERN>
.fam
.fi
.if n .RE
.sp
With greater\-than/less\-than operators it looks like:
.sp
.if n .RS 4
.nf
.fam C
<NEGATION> <TARGET> <CLIENT/FRAME> [<INDEX>] : <FORMAT> <TYPE> <NEGATION> <OPERATOR> <PATTERN>
.fam
.fi
.if n .RE
.sp
\fINEGATION\fP (optional) is one or more exclamation marks;
.sp
\fITARGET\fP is either a predefined target name, or the name of a window property to match. Supported predefined targets are \f(CRid\fP, \f(CRx\fP, \f(CRy\fP, \f(CRx2\fP (\f(CRx\fP + \f(CRwidthb\fP), \f(CRy2\fP (like \f(CRx2\fP), \f(CRwidth\fP, \f(CRheight\fP, \f(CRwidthb\fP (\f(CRwidth\fP + 2 * \f(CRborder_width\fP), \f(CRheightb\fP (like \f(CRwidthb\fP), \f(CRborder_width\fP, \f(CRfullscreen\fP, \f(CRoverride_redirect\fP, \f(CRargb\fP (whether the window has an ARGB visual), \f(CRfocused\fP, \f(CRwmwin\fP (whether the window looks like a WM window, i.e. has no child window with \f(CRWM_STATE\fP and is not override\-redirected), \f(CRbounding_shaped\fP, \f(CRrounded_corners\fP (requires \fB\-\-detect\-rounded\-corners\fP), \f(CRclient\fP (ID of client window), \f(CRwindow_type\fP (window type in string), \f(CRleader\fP (ID of window leader), \f(CRname\fP, \f(CRclass_g\fP (= \f(CRWM_CLASS[1]\fP), \f(CRclass_i\fP (= \f(CRWM_CLASS[0]\fP), and \f(CRrole\fP.
.sp
\fICLIENT/FRAME\fP is a single \f(CR@\fP if the window attribute should be be looked up on client window, nothing if on frame window;
.sp
\fIINDEX\fP (optional) is the index number of the property to look up. For example, \f(CR[2]\fP means look at the third value in the property. If not specified, the first value (index \f(CR[0]\fP) is used implicitly. Use the special value \f(CR[*]\fP to perform matching against all available property values using logical OR. Do not specify it for predefined targets.
.sp
\fIFORMAT\fP (optional) specifies the format of the property, 8, 16, or 32. On absence we use format X reports. Do not specify it for predefined or string targets.
.sp
\fITYPE\fP is a single character representing the type of the property to match for: \f(CRc\fP for \fICARDINAL\fP, \f(CRa\fP for \fIATOM\fP, \f(CRw\fP for \fIWINDOW\fP, \f(CRd\fP for \fIDRAWABLE\fP, \f(CRs\fP for \fISTRING\fP (and any other string types, such as \fIUTF8_STRING\fP). Do not specify it for predefined targets.
.sp
\fIOP QUALIFIER\fP (optional), applicable only for equals operator, could be \f(CR?\fP (ignore\-case).
.sp
\fIMATCH TYPE\fP (optional), applicable only for equals operator, could be nothing (exact match), \f(CR*\fP (match anywhere), \f(CR^\fP (match from start), \f(CR%\fP (wildcard), or \f(CR~\fP (PCRE regular expression).
.sp
\fIOPERATOR\fP is one of \f(CR=\fP (equals), \f(CR<\fP, \f(CR>\fP, \f(CR<=\fP, \f(CR=>\fP, or nothing (exists). Exists operator checks whether a property exists on a window (but for predefined targets, exists means != 0 then).
.sp
\fIPATTERN\fP is either an integer or a string enclosed by single or double quotes. Python\-3\-style escape sequences and raw string are supported in the string format.
.sp
Supported logical operators are \f(CR&&\fP (and) and \f(CR||\fP (or). \f(CR&&\fP has higher precedence than \f(CR||\fP, left\-to\-right associativity. Use parentheses to change precedence.
.sp
Examples:
.sp
.if n .RS 4
.nf
.fam C
# If the window is focused
focused
focused = 1
# If the window is not override\-redirected
!override_redirect
override_redirect = false
override_redirect != true
override_redirect != 1
# If the window is a menu
window_type *= "menu"
_NET_WM_WINDOW_TYPE@:a *= "MENU"
# If the window is marked hidden: _NET_WM_STATE contains _NET_WM_STATE_HIDDEN
_NET_WM_STATE@[*]:a = "_NET_WM_STATE_HIDDEN"
# If the window is marked sticky: _NET_WM_STATE contains an atom that contains
# "sticky", ignore case
_NET_WM_STATE@[*]:a *?= "sticky"
# If the window name contains "Firefox", ignore case
name *?= "Firefox"
_NET_WM_NAME@:s *?= "Firefox"
# If the window name ends with "Firefox"
name %= "*Firefox"
name ~= "Firefox$"
# If the window has a property _COMPTON_SHADOW with value 0, type CARDINAL,
# format 32, value 0, on its frame window
_COMPTON_SHADOW:32c = 0
# If the third value of _NET_FRAME_EXTENTS is less than 20, or there\*(Aqs no
# _NET_FRAME_EXTENTS property on client window
_NET_FRAME_EXTENTS@[2]:32c < 20 || !_NET_FRAME_EXTENTS@:32c
# The pattern here will be parsed as "dd4"
name = "\(rsx64\(rsx64\(rso64"
# The pattern here will be parsed as "\(rsx64\(rsx64\(rsx64"
name = r"\(rsx64\(rsx64\(rso64"
.fam
.fi
.if n .RE
.SH "LEGACY FORMAT OF CONDITIONS"
.sp
This is the old condition format we once used. Support of this format might be removed in the future.
.sp
.if n .RS 4
.nf
.fam C
condition = TARGET:TYPE[FLAGS]:PATTERN
.fam
.fi
.if n .RE
.sp
\fITARGET\fP is one of "n" (window name), "i" (window class instance), "g" (window general class), and "r" (window role).
.sp
\fITYPE\fP is one of "e" (exact match), "a" (match anywhere), "s" (match from start), "w" (wildcard), and "p" (PCRE regular expressions, if compiled with the support).
.sp
\fIFLAGS\fP could be a series of flags. Currently the only defined flag is "i" (ignore case).
.sp
\fIPATTERN\fP is the actual pattern string.
.SH "CONFIGURATION FILES"
.sp
picom could read from a configuration file if libconfig support is compiled in. If \fB\-\-config\fP is not used, picom will seek for a configuration file in \f(CR$XDG_CONFIG_HOME/picom.conf\fP (\f(CR~/.config/picom.conf\fP, usually), then \f(CR$XDG_CONFIG_HOME/picom/picom.conf\fP, then \f(CR$XDG_CONFIG_DIRS/picom.conf\fP (often \f(CR/etc/xdg/picom.conf\fP), then \f(CR$XDG_CONFIG_DIRS/picom/picom.conf\fP.
.sp
picom uses general libconfig configuration file format. A sample configuration file is available as \f(CRpicom.sample.conf\fP in the source tree. Most of commandline switches can be used as options in configuration file as well. For example, \fB\-\-vsync\fP option documented above can be set in the configuration file using `vsync = `. Command line options will always overwrite the settings in the configuration file.
.sp
Window\-type\-specific settings are exposed only in configuration file and has the following format:
.sp
.if n .RS 4
.nf
.fam C
wintypes:
{
  WINDOW_TYPE = { fade = BOOL; shadow = BOOL; opacity = FLOAT; focus = BOOL; blur\-background = BOOL; full\-shadow = BOOL; clip\-shadow\-above = BOOL; redir\-ignore = BOOL; };
};
.fam
.fi
.if n .RE
.sp
\fIWINDOW_TYPE\fP is one of the 15 window types defined in EWMH standard: "unknown", "desktop", "dock", "toolbar", "menu", "utility", "splash", "dialog", "normal", "dropdown_menu", "popup_menu", "tooltip", "notification", "combo", and "dnd".
.sp
Following per window\-type options are available:
.RS 4
.sp
fade, shadow
.RS 4
Controls window\-type\-specific shadow and fade settings.
.RE
.sp
opacity
.RS 4
Controls default opacity of the window type.
.RE
.sp
focus
.RS 4
Controls whether the window of this type is to be always considered focused. (By default, all window types except "normal" and "dialog" has this on.)
.RE
.sp
blur\-background
.RS 4
Controls wether the window of this type will have its transparent background blurred.
.RE
.sp
full\-shadow
.RS 4
Controls whether shadow is drawn under the parts of the window that you normally won\(cqt be able to see. Useful when the window has parts of it transparent, and you want shadows in those areas.
.RE
.sp
clip\-shadow\-above
.RS 4
Controls wether shadows that would have been drawn above the window should be clipped. Useful for dock windows that should have no shadow painted on top.
.RE
.sp
redir\-ignore
.RS 4
Controls whether this type of windows should cause screen to become redirected again after been unredirected. If you have \fB\-\-unredir\-if\-possible\fP set, and doesn\(cqt want certain window to cause unnecessary screen redirection, you can set this to \f(CRtrue\fP.
.RE
.RE
.SH "BLUR"
.sp
You can configure how the window background is blurred using a \fIblur\fP section in your configuration file. Here is an example:
.sp
.if n .RS 4
.nf
.fam C
blur:
{
  method = "gaussian";
  size = 10;
  deviation = 5.0;
};
.fam
.fi
.if n .RE
.sp
Available options of the \fIblur\fP section are:
.RS 4
.sp
\fBmethod\fP
.RS 4
A string. Controls the blur method. Corresponds to the \fB\-\-blur\-method\fP command line option. Available choices are:
\fInone\fP to disable blurring; \fIgaussian\fP for gaussian blur; \fIbox\fP for box blur; \fIkernel\fP for convolution blur with a custom kernel; \fIdual_kawase\fP for dual\-filter kawase blur.
Note: \fIgaussian\fP, \fIbox\fP and \fIdual_kawase\fP blur methods are only supported by the experimental backends.
(default: none)
.RE
.sp
\fBsize\fP
.RS 4
An integer. The size of the blur kernel, required by \fIgaussian\fP and \fIbox\fP blur methods. For the \fIkernel\fP method, the size is included in the kernel. Corresponds to the \fB\-\-blur\-size\fP command line option (default: 3).
.RE
.sp
\fBdeviation\fP
.RS 4
A floating point number. The standard deviation for the \fIgaussian\fP blur method. Corresponds to the \fB\-\-blur\-deviation\fP command line option (default: 0.84089642).
.RE
.sp
\fBstrength\fP
.RS 4
An integer in the range 0\-20. The strength of the \fIdual_kawase\fP blur method. Corresponds to the \fB\-\-blur\-strength\fP command line option. If set to zero, the value requested by \fB\-\-blur\-size\fP is approximated (default: 5).
.RE
.sp
\fBkernel\fP
.RS 4
A string. The kernel to use for the \fIkernel\fP blur method, specified in the same format as the \fB\-\-blur\-kerns\fP option. Corresponds to the \fB\-\-blur\-kerns\fP command line option.
.RE
.RE
.SH "SIGNALS"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
picom reinitializes itself upon receiving \f(CRSIGUSR1\fP.
.RE
.SH "D\-BUS API"
.sp
It\(cqs possible to control picom via D\-Bus messages, by running picom with \fB\-\-dbus\fP and send messages to \f(CRcom.github.chjj.compton.<DISPLAY>\fP. \f(CR<DISPLAY>\fP is the display used by picom, with all non\-alphanumeric characters transformed to underscores. For \f(CRDISPLAY=:0.0\fP you should use \f(CRcom.github.chjj.compton._0_0\fP, for example.
.sp
The D\-Bus methods and signals are not yet stable, thus undocumented right now.
.SH "EXAMPLES"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Disable configuration file parsing:
.sp
.if n .RS 4
.nf
.fam C
$ picom \-\-config /dev/null
.fam
.fi
.if n .RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Run picom with client\-side shadow and fading, disable shadow on dock windows and drag\-and\-drop windows:
.sp
.if n .RS 4
.nf
.fam C
$ picom \-cCGf
.fam
.fi
.if n .RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Same thing as above, plus making inactive windows 80% transparent, making frame 80% transparent, don\(cqt fade on window open/close, and fork to background:
.sp
.if n .RS 4
.nf
.fam C
$ picom \-bcCGf \-i 0.8 \-e 0.8 \-\-no\-fading\-openclose
.fam
.fi
.if n .RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Draw white shadows:
.sp
.if n .RS 4
.nf
.fam C
$ picom \-c \-\-shadow\-red 1 \-\-shadow\-green 1 \-\-shadow\-blue 1
.fam
.fi
.if n .RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Avoid drawing shadows on wbar window:
.sp
.if n .RS 4
.nf
.fam C
$ picom \-c \-\-shadow\-exclude \*(Aqclass_g = "wbar"\*(Aq
.fam
.fi
.if n .RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Enable VSync with GLX backend:
.sp
.if n .RS 4
.nf
.fam C
$ picom \-\-backend glx \-\-vsync
.fam
.fi
.if n .RE
.RE
.SH "BUGS"
.sp
Please submit bug reports to \c
.URL "https://github.com/yshui/picom" "" "."
.sp
Out dated information in this man page is considered a bug.
.SH "RESOURCES"
.sp
Homepage: \c
.URL "https://github.com/yshui/picom" "" ""
.SH "SEE ALSO"
.sp
\fBxcompmgr\fP(1), \c
.URL "picom\-trans.html" "\fBpicom\-trans\fP(1)" ""