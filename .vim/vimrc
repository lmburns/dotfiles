"============================================================================
"    Author: Lucas Burns                                                   
"     Email: burnsac@me.com                                                
"      Home: https://github.com/lmburns                                    
"============================================================================

scriptencoding utf-8
set ttyfast
set nocompatible
let mapleader=' '
let maplocalleader=','
let $VIMHOME = $HOME..'/.vim'
let $VIMPLUGGED = $VIMHOME..'/plugged'
let $VIMPLUGS = $VIMHOME..'/bundles'

let g:c_gnu = 1                  " GNU gcc specific settings
let g:c_syntax_for_h = 1         " use C syntax instead of C++ for .h
let g:c_space_errors = 1         " highlight space errors
let g:c_curly_error = 1          " highlight missing '}'
let g:c_comment_strings = 1      " strings and numbers in comment
" let g:c_no_trail_space_error = 0 " don't highlight trailing space
" let g:c_no_comment_fold = 0      " don't fold comments
" let g:c_no_cformat = 0           " don't highlight %-formats in strings
" let g:c_no_if0 = 0               " don't highlight "#if 0" blocks as comments
" let g:c_no_if0_fold = 0          " don't fold #if 0 blocks
let g:c_ansi_typedefs = 1        " do ANSI types
let g:c_ansi_constants = 1       " do ANSI constants

let g:desktop_enable_nonstd = 1  " highlight nonstd ext. of .desktop files
let g:load_doxygen_syntax = 1    " enable doxygen syntax
let g:doxygen_enhanced_color = 1 " use nonstd hl for doxygen comments

let g:html_syntax_folding = 1
let g:vim_json_conceal = 0     " don't conceal json
let g:lifelines_deprecated = 1 " hl deprecated funcs as errors

let g:nroff_is_groff = 1
let g:nroff_space_errors = 1
"let b:preprocs_as_sections = 1

" let g:perl_no_scope_in_variables = 0 " don't hl pkgname differently in '$PkgName::Var'
" let g:perl_no_extended_vars = 0      " don't hl complex variables
let g:perl_string_as_statement = 1   " highlight string different if 2 on same line
let g:perl_fold = 1
let g:perl_fold_blocks = 1
let g:perl_fold_anonymous_subs = 1

let g:sh_fold_enabled = 1              " enable folding in bash files
let g:ruby_operators = 1
let g:ruby_fold = 1
let g:sed_highlight_tabs = 1
let g:no_man_maps = 1
let g:vimsyn_embed = "lPr"
let g:vimsyn_folding = "afP"

" === Base ================================================================ [[[
" Allow mapping more keycodes. :h modifyOtherKeys
" https://superuser.com/questions/121568/mapping-left-alt-key-in-vim
let &t_TI = "\<Esc>[>4;2m"
let &t_TE = "\<Esc>[>4;m"
" call usr#core#meta#setup()
set path+=**
set rtp-=/usr/share/vim/vimfiles
set shell=$SHELL
set encoding=utf-8
set fileencoding=utf-8
set fileformat=unix
set fileformats=unix,dos
set nrformats=octal,hex,bin,unsigned,alpha
set langmenu=en_US
let $LANG = 'en_US'
" ]]]

" === Files =============================================================== [[[
" UndoHistory: store undo history in a file. even after closing and reopening vim
if has('persistent_undo')
  let target = expand('$VIMHOME/dirs/persistent_undo/')
  if !isdirectory(target)
    call mkdir(target, 'p')
  endif

  let &undodir=target
  set undofile
  set undolevels=1000
  set undoreload=10000
endif

if exists('+viminfo')
  let &viminfofile=expand('$VIMHOME/dirs/viminfo')
  set viminfo=!,'1000,/5000,:5000,<20,@1000,h,s100
end

if exists('+viewdir')
 let target = expand('$VIMHOME/dirs/viewdir/')
 if !isdirectory(target)
   call mkdir(target, 'p')
 endif

 let &viewdir=target
 set viewoptions=cursor,folds
 set sessionoptions=globals,buffers,curdir,tabpages,winsize,winpos,help
end

" set autowriteall
" set autochdir
" set secure
" set exrc
" set autoread
" ]]]

" === Spellcheck ========================================================== [[[
set completeopt+=menuone,preview,noselect
set complete+=kspell
set complete-=w,b,u,t
set spelllang=en_us
set spelloptions+=camel
set spellcapcheck=''
set spellsuggest^=10
let &spellfile=expand('$VIMHOME/dirs/en.utf-8.add')
" ]]]

set magic
set infercase
set ignorecase
set smartcase
set wrapscan           " searches wrap around the end of the file
set incsearch          " incremental search highlight
set hlsearch

set lazyredraw         " screen not redrawn with macros, registers
set updatetime=2000
set redrawtime=2000    " time it takes to redraw ('hlsearch', 'inccommand')
set timeoutlen=375     " time to wait for mapping sequence to complete
set ttimeoutlen=50     " time to wait for keysequence to complete used for ctrl-\ - ctrl-g

set confirm            " confirm when editing readonly
set report=2           " report if at least 1 line changed

set belloff=all
set novisualbell
set noerrorbells
set t_vb=

set title
set titlelen=70
set titlestring=%(%m%)%(%{expand(\"%:~\")}%)
" let &titleold=fnamemodify(&shell, ':t')
set titleold=zsh

if has('mouse')
 set mouse=a
 set mousefocus
 set mousemoveevent
 set mousemodel=popup

 if !has('nvim')
   " Make mouse work with Vim in tmux
   try
     set ttymouse=sgr
   catch
     set ttymouse=xterm2
   endtry
 endif
endif

" set selectmode=
set keymodel-=stopsel " do not stop visual selection with cursor keys
set selection=inclusive

set tagfunc=CocTagFunc
set switchbuf=useopen,uselast
" set jumpoptions=stack,view

set matchpairs+=<:>    " pairs to highlight with showmatch
set showmatch          " when inserting pair, jump to matching one
set matchtime=2        " ms to blink when matching brackets

set hidden
set showcmdloc=last
set ruler showmode
" set noruler noshowmode
set showcmd
set modeline
set modelines=5
set cmdheight=2
set pumheight=10
set showtabline=2
set synmaxcol=300   " don't highlight long lines
set laststatus=2    " when last window has stl
set history=500     " keep 500 lines of command line history

set cursorline
set cursorlineopt=number,screenline
set scrolloff=5
set sidescrolloff=10
set sidescroll=1
set textwidth=100
set winminwidth=2
set noequalalways
set splitright
set splitbelow

set numberwidth=4
set number
set relativenumber
set signcolumn=yes

" === Fold ================================================================ [[[
set foldenable
set foldcolumn=1
set foldlevel=99
set foldlevelstart=99
set foldopen=block,hor,mark,percent,quickfix,search,tag,undo
set foldmethod=marker
set foldmarker=[[[,]]]
" set foldmethod=indent
" set foldmethod=expr
" set foldexpr=nvim_treesitter#foldexpr()
" ]]]

" === Autocompletion ====================================================== [[[
set wildmenu
set wildmode=longest:full,full
set wildignore+=.git,.DS_Store,node_modules
set wildignore+=*~,*.git,*.lock,*.wav,*.avi,*.png
set wildignore+=*.o,*.pyc,*.swp,*.aux,*.out,*.toc,*.o,*.obj,*.dll,*.jar
set wildignore+=*.pyc,*.rbc,*.class,*.gif,*.ico,*.jpg,*.jpeg
set wildignorecase
set wildoptions=pum,fuzzy
set wildcharm=<Tab>
set wildchar=<Tab>
" ]]]

if has('virtualedit')
 set virtualedit=block
endif
set cedit=<C-c>
set nostartofline

set display=lastline
set list
set listchars=tab:‣\ ,trail:•,nbsp:␣,precedes:«,extends:…

set conceallevel=2
set concealcursor=c

"  ▽  ▾ 
"  ▶  ▸  |
set fillchars+=stl:\ ,stlnc:\ ,vert:┃,lastline:@,eob:\ ,diff:╱
set fillchars+=fold:,foldopen:,foldsep:│,foldclose:

" TODO: delete-insert

set cpoptions+=I
set shortmess+=acsIST
set whichwrap+=<,>,[,],b,h,l,s
set wrap
set wrapmargin=2

set nojoinspaces
set formatoptions+=1qnMjlp/ro
set formatoptions-=vct
set formatlistpat=^\s*\%(\d\+[\]:.)}\t\ \|[-*+]\+\)\s*\|^\[^\ze[^\]]\+\]:

set shiftwidth=2
set tabstop=2
set softtabstop=2
set expandtab
set smarttab
set shiftround
set backspace=eol,start,indent

" set indentexpr=nvim_treesitter#indent()
set autoindent     " copy indent from current line when starting a new line (<CR>, o, O)
set smartindent    " smart autoindenting when starting a new line (C-like progs)
set cindent        " automatic C program indenting
" set copyindent     " copy structure of existing lines indent when autoindenting a new line
" set preserveindent " preserve most indent structure as possible when reindenting line

if exists('+breakindent')
 set breakindentopt=sbr,list:2,min:20,shift:2
 set breakindent             " each wrapped line will continue same indent level
endif
set showbreak=↳
set linebreak               " lines wrap at words rather than random characters
set breakat=\ ^I!@*-+;:,./? " which chars cause break with 'linebreak'
" set comments=s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-  " strings that can start a comment line

" set cinoptions=>1s,L0,=1s,l1,b1,g1s,h1s,N0,E0,p1s,t0,i1s,+0,c1S,(1s,u1s,U1,k1s,m1,j1,J1,)40,*70,#0,P1
" set cinkeys=0},0),0],:,!^F,o,O,e

set diffopt+=internal,filler,closeoff,iwhite,vertical,algorithm:histogram,context:4,indent-heuristic
set grepprg=rg\ --with-filename\ --no-heading\ --max-columns=200\ --vimgrep\ --smart-case\ --color=never\ --follow
set grepprg+=\ --glob=!.git\ --glob=!target\ --glob=!node_modules
set grepformat^=%f:%l:%c:%m
" set grepformat=%f:%l:%c:%m,%f:%l:%m

 " === GUI ================================================================= [[[
 set background=dark

 if has("termguicolors")
   set termguicolors
 endif

 if has('gui_running')
   set t_Co=256
   set guioptions-=T
   set guioptions-=e
   set guitablabel=%M\ %t
   " set hlsearch
   syntax on
 endif

 if !exists('g:neovide')
   set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
         \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
         \,sm:block-blinkwait175-blinkoff150-blinkon175

   let &t_SI = "\<Esc>[6 q"
   let &t_SR = "\<Esc>[4 q"
   let &t_EI = "\<Esc>[2 q"
 endif

 set guifont=FiraCode\ Nerd\ Font\ Mono:h13
 set noemoji
  " ]]]

  " === Clipboard =========================================================== [[[
  if exists('$DISPLAY') && executable('xsel')
    let g:clipboard = {
          \   'name': 'xsel',
          \   'copy': {
          \      '+': ['xsel', '--nodetach', '-i', '-b'],
          \      '*': ['xsel', '--nodetach', '-i', '-p'],
          \    },
          \   'paste': {
          \      '+': ['xsel', '-o', '-b'],
          \      '*': ['xsel', '-o', '-p'],
          \   },
          \   'cache_enabled': 1,
          \ }
  elseif exists('$TMUX')
    let g:clipboard = {
          \   'name': 'tmux',
          \   'copy': {
          \      '+': ['tmux', 'load-buffer', '-w', '-'],
          \      '*': ['tmux', 'load-buffer', '-w', '-'],
          \    },
          \   'paste': {
          \      '+': ['tmux', 'save-buffer', '-'],
          \      '*': ['tmux', 'save-buffer', '-'],
          \   },
          \   'cache_enabled': 1,
          \ }
  endif

  set clipboard=unnamedplus,unnamed
  " ]]]

  " ]]] === General Settings ===

  try
    set rtp+=$VIMHOME/bundle/neobundle.vim
    let s:bundles_path = expand($VIMPLUGS)
    call neobundle#begin(s:bundles_path)
    let s:use_neobundle = 1
  catch
    echom "NeoBundle not found!"
    echom "Error:" v:exception
    let s:use_neobundle = 0
  endtry

  if s:use_neobundle
    let g:neobundle#enable_name_conversion = 1
    let g:neobundle#default_options = {
          \ 'manual': {'base': '~/.vim/bundle', 'type': 'nosync'},
          \ 'colors': {'script_type' : 'colors' }}
  endif

  " name            (String)
  " normalized_name (String)
  " description     (String)
  " rev             (String) revision
  " default         (String) default opt name
  " directory       (String) rel dir from base
  " base            (String) dir base path
  " type            (String) repo type            none, raw, git, hg, svn , vba
  " script_type     (String) script type          indent, plugin, ftplugin, etc
  " site            (String) repo site            gh, bb, gist
  " rtp             (String) runtime path
  " depends         (List/String) dependencies
  " build           (Dict/String) build script
  " augroup         (String)      augroup name plugin uses
  " external_commands (Dict/List/String) external commands required
  " build_commands    (Dictionary or List or String)
  " frozen            (Number) 1 and won't update auto
  " lazy              (Number) 1 and doesn't add to rtp
  " fetch             (Number) 1 and doesn't add to rtp and doesnt load
  " force             (Number) 1 and force
  " gui               (Number) 1 and only load GUI
  " terminal          (Number) 1 and only load terminal
  " vim_version       (String) required version
  " disabled          (Number/Str) 1 and disabled
  " focus             (Number) > 0 and sourced when focuslost
  " verbose           (Number) 1 and print msg when sourced
  " install_process_timeout (Number)
  " autoload          (Dict) autoload conds
  " on_map            (List/String)
  " on_ft             (List/String)
  " hooks             (Dictionary)
  " on_cmd            (List/String)
  " on_func           (List/String)
  " on_i              (Number)
  " on_source         (List/String)
  " pre_cmd           (List/String)
  " on_path           (String) or (List)

  "https://github.com/henrik/dotfiles " un-join (split) the current line at the cursor position
  " nnoremap gj i<c-j><esc>k$

  NeoBundleFetch 'Shougo/neobundle.vim',
        \ {'description': 'Let neobundle manage neobundle'}
  NeoBundle 'liuchengxu/vim-which-key',
        \ {'hooks': {'on_source': {-> plugs#whichkey#setup()}}}
  NeoBundleLazy 'dstein64/vim-startuptime',
        \ {'on_cmd': 'StartupTime'}

  NeoBundle 'tpope/vim-repeat'
  NeoBundle 'tpope/vim-scriptease'
  NeoBundle 'roxma/vim-hug-neovim-rpc'
  NeoBundle 'drmikehenry/vim-fixkey'
  NeoBundle 'inkarkat/vim-ingo-library'
  NeoBundle 'ryanoasis/vim-devicons'

  " ============= targets ============== [[[
  NeoBundleLazy 'arthurxavierx/vim-caser',
        \ {'on_map': ['n', 'cr'],
        \  'hooks': {'on_source': {-> plugs#conf#caser()}}}

  NeoBundleLazy 'haya14busa/vim-asterisk',
        \ {'on_map': [['n', '*'], ['n', 'g*'],
        \             ['x', '*'], ['x', 'g*'],
        \             ['n', '#'], ['n', 'g#'],
        \             ['x', '#'], ['x', 'g#']],
        \  'hooks': {'on_source': {-> plugs#asterisk#setup()}}}

  NeoBundle 'wellle/targets.vim',
        \ {'depends': ['wellle/line-targets.vim'],
        \  'hooks': {'on_source': {-> plugs#textobjs#targets_setup()}}}
  NeoBundle 'machakann/vim-sandwich',
        \ {'hooks': {'on_source': {-> plugs#textobjs#sandwich_setup()}}}
  NeoBundle 'andymass/vim-matchup',
        \ {'hooks': {'on_source': {-> plugs#textobjs#matchup_setup()}}}

  NeoBundle 'kana/vim-operator-user'
  NeoBundle 'kana/vim-textobj-user'
  let g:textobj_fold_no_default_key_mappings = 1
  let g:textobj_entire_no_default_key_mappings = 1
  let g:textobj_indent_no_default_key_mappings = 1
  let g:textobj_function_no_default_key_mappings = 1
  let g:textobj_syntax_no_default_key_mappings = 1
  let g:textobj_lastpat_no_default_key_mappings = 1
  NeoBundleLazy 'kana/vim-textobj-fold',
        \ {'on_map': [['o', 'iz'], ['o', 'az'],
        \             ['x', 'iz'], ['x', 'az']],
        \  'hooks': {'on_source': {-> plugs#textobjs#fold_setup()}}}
  NeoBundleLazy 'kana/vim-textobj-entire',
        \ {'on_map': [['o', 'ie'], ['o', 'ae'],
        \             ['x', 'ie'], ['x', 'ae']],
        \  'hooks': {'on_source': {-> plugs#textobjs#entire_setup()}}}
  NeoBundleLazy 'kana/vim-textobj-indent',
        \ {'on_map': [['o', 'ii'], ['o', 'ai'], ['o', 'iI'], ['o', 'aI'],
        \             ['x', 'ii'], ['x', 'ai'], ['x', 'iI'], ['x', 'aI']],
        \  'hooks': {'on_source': {-> plugs#textobjs#indent_setup()}}}
  NeoBundleLazy 'kana/vim-textobj-function',
        \ {'on_map': [['o', 'if'], ['o', 'af'], ['o', 'iF'], ['o', 'aF'],
        \             ['x', 'if'], ['x', 'af'], ['x', 'iF'], ['x', 'aF']],
        \  'hooks': {'on_source': {-> plugs#textobjs#function_setup()}}}
  NeoBundle 'kana/vim-textobj-syntax',
        \ {'on_map': [['o', 'iu'], ['o', 'au'],
        \             ['x', 'iu'], ['x', 'au']],
        \  'hooks': {'on_source': {-> plugs#textobjs#function_setup()}}}
  NeoBundle 'kana/vim-textobj-lastpat',
        \  {'hooks': {'on_source': {-> plugs#textobjs#lastpat_setup()}}}
  NeoBundle 'kana/vim-textobj-diff'
  NeoBundle 'kana/vim-textobj-help'

  NeoBundle 'kana/vim-gex'
  NeoBundle 'kana/vim-niceblock'
  NeoBundle 'kana/vim-exjumplist'
  NeoBundle 'kana/vim-tag-user'
  NeoBundle 'kana/vim-better-tag-jump'

  " \ {'on_map': [['n', 'sJ'], ['o', 'sJ'],
  " \             ['n', 'sK'], ['o', 'sK']],
  NeoBundle 'haya14busa/vim-edgemotion',
        \ {'hooks': {'on_source': {-> plugs#textobjs#edge_setup()}}}
  NeoBundle 'michaeljsmith/vim-indent-object'
  NeoBundle 'pseewald/vim-anyfold'

  NeoBundle 'romgrk/replace.vim',
        \ {'hooks': {'on_source': {-> plugs#conf#replace()}}}
  NeoBundle 'tommcdo/vim-exchange',
        \ {'hooks': {'on_source': {-> plugs#conf#exchange()}}}
  NeoBundle 'easymotion/vim-easymotion',
        \ {'hooks': {'on_source': {-> plugs#easymotion#setup()}}}
  "
  " Plug 'guns/vim-sexp'

  " NeoBundleLazy 'Raimondi/delimitMate',
  "       \ {'autoload': {'insert': 1, 'filetypes': 'all'}}
  " ]]] === targets ===

  " TODO:
  NeoBundle 'romainl/vim-cool',
        \ {'description': 'Clear search highlight when not searching'}
  NeoBundle 'junegunn/vim-peekaboo'
        " \ {'on_map': [['n', '"'], ['i', '<C-r>']]}
  NeoBundle 'vim-utils/vim-man'
  NeoBundle 'tyru/open-browser.vim'

  " ================ syntax ================ [[[
  NeoBundle 'luochen1990/rainbow'
  NeoBundle 'yggdroot/indentline',
        \  {'hooks': {'on_source': {-> plugs#indentline#setup()}}}
  " ]]]

  " ================ addons ================ [[[
  NeoBundleLazy 'bootleq/vim-cycle',
        \ {'on_map': [['n', '_'], ['x', '_'], ['s', '_'],
        \             ['n', '+'], ['x', '+'], ['s', '_']],
        \  'hooks': {'on_source': {-> plugs#cycle#setup()}}}
  NeoBundleLazy 'mhinz/vim-grepper',
        \ {'on_cmd': ['Grepper', 'GrepperRg'],
        \  'on_map': [['n', 'gs'], ['x', 'gs'], ['n', '<Leader>rg']],
        \  'hooks': {'on_post_source': {-> plugs#grepper#setup()}}}
  NeoBundleLazy 'junegunn/vim-easy-align',
        \ {'on_cmd': ['EasyAlign', 'LiveEasyAlign'],
        \  'on_map': [['n', 'ga'], ['x', 'ga'],
        \             ['x', '<Leader>ga'], ['x', '<Leader>gi'], ['x', '<Leader>gs']],
        \  'hooks': {'on_source': {-> plugs#align#setup()}}}
  NeoBundleLazy 'ZSaberLv0/eregex.vim',
        \ {'on_cmd': ['E2v', 'S', 'M', 'G', 'V'],
        \  'on_map': [['n', '<Leader>es'], ['n', '<Leader>S'], ['n', ',/']],
        \  'hooks': {'on_source': {-> plugs#conf#eregex()}},
        \  'description': 'Perl regex for vim'}

  NeoBundleLazy 'tweekmonster/helpful.vim',
        \ {'on_cmd': ['HelpfulVersion']}
  NeoBundleLazy 'inkarkat/vim-SpellCheck',
        \ {'on_cmd': ['SpellCheck', 'SpellLCheck']}
  NeoBundleLazy 'AndrewRadev/bufferize.vim',
        \ {'on_cmd': ['Bufferize']}
  NeoBundleLazy 'AndrewRadev/splitjoin.vim',
        \  {'on_map': [['n', 'gJ'], ['n', 'gS']],
        \   'hooks': {'on_source': {-> plugs#conf#splitjoin()}}}
  NeoBundleLazy 'mbbill/undotree',
        \ {'on_cmd': ['UndotreeToggle'],
        \  'on_map': [['n', '<Leader>ut']],
        \  'hooks': {'on_source': '$VIMHOME/autoload/plugs/undotree.vim'}}
  NeoBundleLazy 'kevinhwang91/suda.vim',
        \ {'on_cmd': ['SudaWrite'],
        \  'hooks': {'on_source': {-> plugs#conf#suda()}}}
  NeoBundle 'mg979/vim-visual-multi',
        \  {'hooks': {'on_source': {-> plugs#visualmulti#setup()}}}
  " ]]]

  " ================= repo ================= [[[
  NeoBundle 'airblade/vim-rooter',
        \  {'hooks': {'on_source': {-> plugs#rooter#setup()}}}

  " Plug 'jiangmiao/auto-pairs' | call plugs#autopairs#setup()

  "     silent! call repeat#set("\<Plug>easymotion/easymotion", v:count)
  "     silent! call repeat#set("\<Plug>jiangmiao/auto-pairs", v:count)
  "     silent! call repeat#set("\<Plug>liuchengxu/vim-which-key", v:count)
  "     sil! call repeat#set("\<Plug>justinmk/vim-sneak", v:count)
  "
  " NeoBundle 'rhysd/clever-f.vim'
  " NeoBundle 'justinmk/vim-sneak'
  " NeoBundle 'AndrewRadev/switch.vim'
  " Plug 'karb94/neoscroll.nvim'
  " Plug 'mhartington/formatter.nvim'

  " ============ formatting ============ [[[
  NeoBundleLazy 'sbdchd/neoformat',
        \  {'on_map': [['n', ';ff'], ['x', ';ff']],
        \   'hooks': {'on_source': {-> plugs#format#setup()}}}
  " ]]] === formatting ===
  "
  " ================ git ================= [[[
  " TODO:
  " Plug 'christoomey/vim-conflicted'
  NeoBundleLazy 'AndrewRadev/linediff.vim',
        \ {'on_cmd': ['Linediff', 'LinediffReset'],
        \  'on_map': [['n', '<Leader>ld'], ['x', '<Leader>ld'],
        \             ['n', '<Leader>lD'], ['x', 'D']],
        \  'hooks': {'on_source': {-> plugs#conf#linediff()}}}
  NeoBundle 'tpope/vim-fugitive',
      \   {'hooks': {'on_source': {-> plugs#fugitive#setup()}}}
  NeoBundle 'tpope/vim-rhubarb'
  NeoBundle 'rbong/vim-flog',
      \   {'hooks': {'on_source': {-> plugs#flog#setup()}}}
  NeoBundleLazy 'ruanyl/vim-gh-line',
        \  {'on_map': [['n', '<Leader>go'], ['n', '<Leader>gl']],
        \   'hooks': {'on_source': {-> plugs#git#ghline()}}}
  " ]]] === fugitive ===

  call neobundle#end()

  filetype plugin indent on
  if !has('vim_starting')
    " Call on_source hook when reloading .vimrc.
    call neobundle#call_hook('on_source')
  endif

  " set packpath+=$VIMPLUGGED
  call plug#begin($VIMPLUGGED) " [[[

  " Not needed, here for manual pages
  Plug 'junegunn/vim-plug'
  Plug 'roxma/nvim-yarp', { 'do': 'pip install -r requirements.txt' }

  " ============= targets ============== [[[
  " Plug 'tpope/vim-surround'
  " Plug 'tpope/vim-abolish'
  " TODO:

  " Plug 'KabbAmine/vCoolor.vim'
  " Plug 'tpope/vim-characterize',
  " Plug 'vim-scripts/visualrepeat'
  " Plug 'sickill/vim-pasta'
  " Plug 'chrisbra/Colorizer'

  " Plug 'rhysd/git-messenger.vim', {'on': 'GitMessenger'}
  " Plug 'airblade/vim-gitgutter', {'on': 'GitGutterToggle'}
  " Plug 'tpope/vim-eunuch',
  " Plug 'aymericbeaumet/vim-symlink'
  " Plug 'will133/vim-dirdiff'
  " Plug 'justinmk/vim-dirvish'
  " Plug 'justinmk/vim-printf'

  " Plug 'SirVer/ultisnips'
  " Plug 'honza/vim-snippets'

  " Plug 'MTDL9/vim-log-highlighting'
  " Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }
  " Plug 'moll/vim-bbye', { 'on': ['Bdelete', 'Bwipeout'] }

  " Plug 'itchyny/vim-cursorword'            " Underlines words under cursor
  " Plug 'vim-scripts/a.vim'                 " Open the header file with :AT

  " Plug 'xolox/vim-easytags'
  " ]]] === targets ===

  "https://github.com/henrik/dotfiles " un-join (split) the current line at the cursor position
  " nnoremap gj i<c-j><esc>k$

  " ================ addons ================ [[[
  " Plug 'tpope/vim-endwise' | let g:endwise_no_mappings = 1
  " Plug 'maxbrunsfeld/vim-yankstack'

  Plug 'junegunn/fzf', {'do': {-> fzf#install()}} | Plug 'junegunn/fzf.vim'
  " ]]]

  " ============== nerdcommenter ============== [[[
  " Plug 'tomtom/tcomment_vim'
  Plug 'tpope/vim-commentary'
  Plug 'preservim/nerdcommenter'
  let NERDSpaceDelims = 1
  let g:NERDCreateDefaultMappings = 0
  let g:NERDTrimTrailingWhitespace = 1
  let g:NERDToggleCheckAllLines = 1
  let g:NERDCompactSexyComs = 1
  let g:NERDCommentEmptyLines = 1
  let g:NERDDefaultAlign = 'left'
  let g:NERDCustomDelimiters = { 'just': { 'left': '#'}}
  nnoremap <C-.> :call nerdcommenter#Comment(0, "Toggle")<CR>j
  xnoremap <C-.> :call nerdcommenter#Comment(0, "Toggle")<CR>'>j
  xnoremap gc :call nerdcommenter#Comment(0, "Toggle")<CR>
  nnoremap gcl :call nerdcommenter#Comment(0, "AlignLeft")<CR>
  xnoremap gcl :call nerdcommenter#Comment(0, "AlignLeft")<CR>
  nnoremap gcr :call nerdcommenter#Comment(0, "AlignRight")<CR>
  xnoremap gcr :call nerdcommenter#Comment(0, "AlignRight")<CR>
  nnoremap gcL :call nerdcommenter#Comment(0, "ToEOL")<CR>
  nnoremap gcA :call nerdcommenter#Comment(0, "Append")<CR>
  nnoremap gcy :call nerdcommenter#Comment(0, "Yank")<CR>
  xnoremap gcy :call nerdcommenter#Comment(0, "Yank")<CR>
  " ]]] === nerdcomment ===

  "
  "| ----------------------- | ------------------------------------------------ |
  "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |
  "| `rtp`                   | Subdirectory that contains Vim plugin            |
  "| `dir`                   | Custom directory for the plugin                  |
  "| `as`                    | Use different name for the plugin                |
  "| `do`                    | Post-update hook (string or funcref)             |
  "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |
  "| `for`                   | On-demand loading: File types                    |
  "| `frozen`                | Do not update unless explicitly specified        |

  " ============== lightline-buffer ============== [[[
  " Plug 'sainnhe/tmuxline.vim', {'on': ['Tmuxline', 'TmuxlineSnapshot']}
  Plug 'mengelbrecht/lightline-bufferline'
  " jump mapping
  nmap ,1 <Plug>lightline#bufferline#go(1)
  nmap ,2 <Plug>lightline#bufferline#go(2)
  nmap ,3 <Plug>lightline#bufferline#go(3)
  nmap ,4 <Plug>lightline#bufferline#go(4)
  nmap ,5 <Plug>lightline#bufferline#go(5)
  nmap ,6 <Plug>lightline#bufferline#go(6)
  nmap ,7 <Plug>lightline#bufferline#go(7)
  nmap ,8 <Plug>lightline#bufferline#go(8)
  nmap ,9 <Plug>lightline#bufferline#go(9)
  nmap ,0 <Plug>lightline#bufferline#go(10)

  " kill mapping
  nmap ;1 <Plug>lightline#bufferline#delete(1)
  nmap ;2 <Plug>lightline#bufferline#delete(2)
  nmap ;3 <Plug>lightline#bufferline#delete(3)
  nmap ;4 <Plug>lightline#bufferline#delete(4)
  nmap ;5 <Plug>lightline#bufferline#delete(5)
  nmap ;6 <Plug>lightline#bufferline#delete(6)
  nmap ;7 <Plug>lightline#bufferline#delete(7)
  nmap ;8 <Plug>lightline#bufferline#delete(8)
  nmap ;9 <Plug>lightline#bufferline#delete(9)
  nmap ;0 <Plug>lightline#bufferline#delete(10)

  let s:nbsp = ' '
  let g:lightline#bufferline#filename_modifier = ":t".s:nbsp
  let g:lightline#bufferline#shorten_path      = 1
  let g:lightline#bufferline#show_number       = 2
  let g:lightline#bufferline#min_buffer_count  = 0
  let g:lightline#bufferline#unnamed           = '[No Name]'
  let g:lightline#bufferline#read_only         = '  '
  let g:lightline#bufferline#modified          = " + "
  let g:lightline#bufferline#enable_devicons = 1
  let g:lightline#bufferline#unicode_symbols = 1
  let g:lightline#bufferline#number_map = {
        \ 0: '⁰', 1: '¹', 2: '²', 3: '³', 4: '⁴',
        \ 5: '⁵', 6: '⁶', 7: '⁷', 8: '⁸', 9: '⁹'}
  " \ 0: '₀', 1: '₁', 2: '₂', 3: '₃', 4: '₄',
  " \ 5: '₅', 6: '₆', 7: '₇', 8: '₈', 9: '₉'}
  let g:lightline#bufferline#unicode_symbols = 1

  let g:lightline#gitdiff#indicator_added = ': '
  let g:lightline#gitdiff#indicator_deleted = ': '
  let g:lightline#gitdiff#indicator_modified = 'ﰲ: '
  let g:lightline#gitdiff#separator = ' '
  " let g:lightline#gitdiff#show_empty_indicators = 1
  " ]]] === lightline-buffer ===

  " ============== lightline ============== [[[
  Plug 'itchyny/lightline.vim'
  Plug 'josa42/vim-lightline-coc'
  Plug 'niklaas/lightline-gitdiff'
  function! CocDiagnosticError() abort "[[[
    let info = get(b:, 'coc_diagnostic_info', {})
    return get(info, 'error', 0) ==# 0 ? '' : ' ' . info['error'] "   
  endfunction "]]]

  function! CocDiagnosticWarning() abort "[[[
    let info = get(b:, 'coc_diagnostic_info', {})
    return get(info, 'warning', 0) ==# 0 ? '' : ' ' . info['warning'] "      !
  endfunction "]]]

  function! CocDiagnosticOK() abort "[[[
    let info = get(b:, 'coc_diagnostic_info', {})
    return get(info, 'error', 0) ==# 0 && get(info, 'warning', 0) ==# 0 ? '' : '' "  
  endfunction "]]]

  function! CocStatus() abort "[[[
    return get(g:, 'coc_status', '')
  endfunction "]]]

  function! GitGlobal() abort "[[[
    if exists('*FugitiveHead')
      let branch = FugitiveHead()
      if branch ==# ''
        return ' ' . fnamemodify(getcwd(), ':t')
      else
        return branch . ' '
      endif
    endif
    return ''
  endfunction "]]]

  function! DeviconsFiletype() "[[[
    return winwidth(0) > 80 ? (strlen(&filetype) ? WebDevIconsGetFileTypeSymbol() . ' ' . &filetype : 'no ft') : ''
    " return winwidth(0) > 100 ? (strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft') : ''
  endfunction "]]]

  function! TabNum(n) abort "[[[
    return a:n." \ue0bb"
  endfunction "]]]

  " FIX: function
  function! NumBufs() abort "[[[
    " let num = len(getbufinfo({'buflisted':1}))
    " let hid = len(filter(getbufinfo({'buflisted':1}), 'empty(v:val.windows)'))
    return len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))
    " return hid ? num-hid."+".hid : num
  endfunction "]]]

  " function! FileSize() abort "[[[
  "   let [ bytes, units, i ] = [ getfsize(expand(@%)), ['', 'Ki', 'Mi', 'Gi'], 0 ]
  "   while bytes >= 1024 | let bytes = bytes / 1024.0 | let i += 1 | endwhile
  "   return printf((i ? "~%.1f" : "%d")." %sB", bytes, units[i])
  " endfunction "]]]

  let g:ll_blacklist = '\v(help|nerdtree|quickmenu|startify|undotree|neoterm|'
        \ . 'fugitive|netrw|vim-plug|floaterm|qf)'

  function! FileSize() abort " [[[
    let l:bytes = getfsize(expand('%:p'))
    if (l:bytes >= 1024)
      let l:kbytes = l:bytes / 1024
    endif
    if (exists('l:kbytes') && l:kbytes >= 1000)
      let l:mbytes = l:kbytes / 1000
    endif

    if l:bytes <= 0
      return &filetype !~# g:ll_blacklist ? ('0 B') : ''
    endif

    if (exists('l:mbytes'))
      return &filetype !~# g:ll_blacklist && winwidth(0) > 70 ? (l:mbytes . ' MB') : ''
    elseif (exists('l:kbytes'))
      return &filetype !~# g:ll_blacklist && winwidth(0) > 70 ? (l:kbytes . ' KB') : ''
    else
      return &filetype !~# g:ll_blacklist && winwidth(0) > 70 ? (l:bytes . ' B') : ''
    endif
  endfunction "]]]

  function! LightLineReadonly() abort "[[[
    return &readonly && &filetype !~# g:ll_blacklist ? '' : ''
  endfunction "]]]

  function! LightlineFilename() abort "[[[
    let filename = expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
    let modified = &modified ? ' +' : ''
    return winwidth(0) > 40 ? filename . modified : ''
  endfunction "]]]

  function! LightlineGitStatus() abort "[[[
    let status = get(b:, 'coc_git_status', '')
    return winwidth(0) > 80 ? status : ''
  endfunction "]]]

  function! LightlineFileEncoding() "[[[
    " only show the file encoding if it's not 'utf-8'
    return &fileencoding == 'utf-8' ? '' : &fileencoding
  endfunction "]]]

  function! NearestMethodOrFunction() abort "[[[
    return get(b:, 'vista_nearest_method_or_function', '')
  endfunction "]]]

  autocmd VimEnter * call vista#RunForNearestMethodOrFunction()

  set showtabline=2
  let g:lightline = {}
  " let g:lightline.colorscheme = 'overcast'
  let g:lightline.colorscheme = 'gruvbox_material'
  " let g:lightline.colorscheme = 'everforest'
  " let g:lightline.colorscheme = 'miramare'
  " let g:lightline.colorscheme = 'nightowl'
  " let g:lightline.colorscheme = 'spaceduck'
  " let g:lightline.colorscheme = 'sonokai'
  let g:lightline.separator = { 'left': "\ue0b8", 'right': "\ue0be" }
  let g:lightline.subseparator = { 'left': "\ue0b9", 'right': "\ue0b9" }
  let g:lightline.tabline_separator = { 'left': "\ue0bc", 'right': "\ue0ba" }
  let g:lightline.tabline_subseparator = { 'left': "\ue0bb", 'right': "\ue0bb" }
  " 'fileformat'
  let g:lightline.active = {
        \ 'left':  [['mode', 'paste'],
        \           ['readonly', 'modified', 'devicons_filetype', 'fsize', 'fileencoding'],
        \           ['gitdiff', 'coc_status']],
        \ 'right': [['lineinfo'],
        \           ['linter_errors', 'linter_warnings', 'linter_ok']]
        \ }
  let g:lightline.inactive = {
        \ 'left': [['filename', 'modified', 'fileformat']],
        \ 'right': [[ 'lineinfo' ]]
        \ }
  " 'tabs'
  let g:lightline.tabline = {
        \ 'right': [[ 'method', 'git_status' ]],
        \ 'left': [['vim_logo', 'nbufs', 'buffers']],
        \ }
  let g:lightline.tab = {
        \ 'active': ['bufnum', 'filename'],
        \ 'inactive': ['bufnum', 'filename']
        \ }
  " \ 'readonly': 'lightline#tab#readonly',
  " \ 'filename': 'lightline#tab#filename',
  " \ 'modified': 'lightline#tab#modified',
  let g:lightline.tab_component_function = {
        \ 'tabnum': 'TabNum',
        \ 'filename': 'LightlineFilename',
        \ }
  " \ 'fileencoding': '%{&fenc!=#""?&fenc:&enc}',
  let g:lightline.component = {
        \ 'git_status' : '%{GitGlobal()}',
        \ 'nbufs': '%{NumBufs()}',
        \ 'bufinfo': '%{bufname("%")}:%{bufnr("%")}',
        \ 'vim_logo': "\ue7c5",
        \ 'mode': '%{lightline#mode()}',
        \ 'absolutepath': '%F',
        \ 'relativepath': '%f',
        \ 'filename': '%t',
        \ 'fileformat': '%{&fenc!=#""?&fenc:&enc}[%{&ff}]',
        \ 'filetype': '%{&ft!=#""?&ft:"no ft"}',
        \ 'modified': '%M',
        \ 'bufnum': '%n',
        \ 'paste': '%{&paste?"PASTE":""}',
        \ 'readonly': '%R',
        \ 'charvalue': '%b',
        \ 'charvaluehex': '%B',
        \ 'percent': '%2p%%',
        \ 'percentwin': '%P',
        \ 'spell': '%{&spell?&spelllang:""}',
        \ 'lineinfo': '%2p%% %3l:%-2v',
        \ 'line': '%l',
        \ 'column': '%c',
        \ 'close': '%999X X ',
        \ 'winnr': '%{winnr()}',
        \ 'method': '%{NearestMethodOrFunction()}',
        \ }
  let g:lightline.component_function = {
        \ 'devicons_filetype': 'DeviconsFiletype',
        \ 'coc_status': 'CocStatus',
        \ 'fsize': 'FileSize',
        \ 'fileencoding': 'LightlineFileEncoding',
        \ }
  let g:lightline.component_expand = {
        \ 'linter_warnings': 'CocDiagnosticWarning',
        \ 'linter_errors': 'CocDiagnosticError',
        \ 'linter_ok': 'CocDiagnosticOK',
        \ 'buffers': 'lightline#bufferline#buffers',
        \ 'readonly': 'LightLineReadonly',
        \ 'gitdiff': 'lightline#gitdiff#get',
        \ }
  let g:lightline.component_type = {
        \ 'linter_warnings': 'warning',
        \ 'linter_errors': 'error',
        \ 'linter_info': 'info',
        \ 'linter_hints': 'hints',
        \ 'buffers': 'tabsel',
        \ 'gitdiff': 'middle',
        \ }
  let g:lightline.mode_map = {
        \ 'n':      'N',
        \ 'i':      'I',
        \ 'R':      'R',
        \ 'v':      'V',
        \ 'V':      'V-L',
        \ "\<C-v>": 'V-B',
        \ 'c':      'C',
        \ 's':      'S',
        \ 'S':      'S-L',
        \ "\<C-s>": 'S-B',
        \ 't':      'T',
        \ }
  " ]]] === lightline ===

  " ============== EasyEscape ============== [[[
  imap jk <ESC>
  imap kj <ESC>
  cnoremap jk <ESC>
  cnoremap kj <ESC>

  " Disables bracketed pasting
  " set t_BE=
  " ]]] === EasyEscape ===

  " ============== gutentag | vista ============== [[[ "
  Plug 'ludovicchabant/vim-gutentags'
  set tags=./tags,./.tags,tags,.tags
  let g:gutentags_cache_dir = expand('~/.cache/tags')
  let g:gutentags_project_root = ['.git', '.root', '.project', 'package.json', 'Cargo.toml', 'go.mod']
  let g:gutentags_exclude_project_root = ['/opt', '/mnt', '/media', '/usr/local', '/etc']
  let g:gutentags_exclude_filetypes = ['text', 'conf', 'markdown', 'vimwiki', 'git', 'gitconfig', 'fugitive']

  let g:gutentags_modules = ['ctags']
  let g:gutentags_ctags_tagfile = 'tags'
  let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extras=+q']
  let g:gutentags_ctags_extra_args += ['--c++-kinds=+px', '--c-kinds=+px']
  let g:gutentags_ctags_extra_args += ['--rust-kinds=+fPM', '--guess-language-eagerly']
  let g:gutentags_gtags_dbpath = g:gutentags_cache_dir
  let g:gutentags_generate_on_new = 1
  let g:gutentags_generate_on_missing = 1
  let g:gutentags_generate_on_write = 1
  let g:gutentags_generate_on_empty_buffer = 0
  let g:gutentags_resolve_symlinks = 1
  let g:gutentags_file_list_command = {
        \ 'markers': {
        \ '.git': 'git ls-files',
        \ '.root': 'fd --color=never --strip-cwd-prefix --type f --hidden --follow --exclude=.git --exclude=.github',
        \ },
        \ }

  let g:gutentags_plus_nomap = 1
  let g:gutentags_auto_add_gtags_cscope = 0
  let g:gutentags_enabled = 1
  let g:gutentags_define_advanced_commands = 1
  let g:gutentags_ctags_exclude = [
        \  '*.git', '*.svn', '*.hg',
        \  'cache', 'build', 'dist', 'bin', 'node_modules', 'bower_components', 'target',
        \  '*-lock.json',  '*.lock',
        \  '*.min.*',
        \  '*.bak',
        \  '*.zip',
        \  '*.pyc',
        \  '*.class',
        \  '*.sln',
        \  '*.csproj', '*.csproj.user',
        \  '*.tmp',
        \  '*.cache',
        \  '*.vscode',
        \  '*.pdb',
        \  '*.exe', '*.dll', '*.bin',
        \  '*.mp3', '*.ogg', '*.flac',
        \  '*.swp', '*.swo',
        \  '.DS_Store', '*.plist',
        \  '*.bmp', '*.gif', '*.ico', '*.jpg', '*.png', '*.svg',
        \  '*.rar', '*.zip', '*.tar', '*.tar.gz', '*.tar.xz', '*.tar.bz2',
        \  '*.pdf', '*.doc', '*.docx', '*.ppt', '*.pptx', '*.xls',
        \]

  function! s:SetupCTags()
    let g:gutentags_ctags_extra_args += ['/usr/include', '/usr/local/include']
  endfunction

  function! s:SetupCPPTags()
    let g:gutentags_ctags_extra_args += ['/home/lucas/.config/nvim/cpp_src']
  endfunction

  function! s:SetupRubyTags()
    " let g:gutentags_ctags_extra_args += map(split($GEM_PATH, ':'), 'v:val."/gems/*/tags"')
    let g:gutentags_ctags_extra_args += ['/home/lucas/.local/share/rbenv/versions/3.1.0/lib/ruby/3.1.0']
  endfunction

  function! s:SetupPerlTags()
    let g:gutentags_ctags_extra_args += ['/home/lucas/.local/share/perl5/perlbrew/build/perl-5.35.4/perl-5.35.4']
  endfunction

  augroup lmb__Gutentags
    autocmd!
    autocmd! User vim-gutentags call gutentags#setup_gutentags()
    autocmd! FileType cpp call <SID>SetupCPPTags()
    autocmd! FileType ruby call <SID>SetupRubyTags()
    autocmd! FileType perl call <SID>SetupPerlTags()
  augroup END
  " endif

  Plug 'liuchengxu/vista.vim'
  let g:vista_fzf_opt = ['--no-border']
  let g:vista_fzf_preview = ['down:50%']
  let g:vista_default_executive = 'coc'
  let g:vista_sidebar_position = 'vertical botright'
  let g:vista_echo_cursor_strategy = 'both'
  let g:vista#renderer#enable_icon = 1
  let g:vista_executive_for = {
        \ 'vimwiki': "markdown",
        \ 'pandoc': "markdown",
        \ 'markdown': "toc",
        \ }

  nmap <C-A-"> :Vista!!<CR>
  nmap <A-\> :Vista finder fzf:coc<CR>
  nmap <A-]> :Vista finder ctags<CR>
  " nmap <C-S-\> :CocCommand fzf-preview.VistaCtags<CR>
  " nmap <A-]> :CocCommand fzf-preview.VistaBufferCtags<CR>
  " nmap <A-]> :<C-u>CocCommand fzf-preview.VistaBufferCtags --add-fzf-arg=--preview-window=':nohidden,bottom:50%'<CR>

  nmap <silent> <Leader>T  :Tags<CR>
  nmap <silent> <A-t> :BTags<CR>
  nmap <silent> <LocalLeader>t  :CocCommand fzf-preview.BufferTags<CR>

  augroup lmb__VistaNearest
    au!
    au VimEnter * call vista#RunForNearestMethodOrFunction()
  augroup END
  " ]]] === gutentag | vista === "

  " ============== Neoterm ============== [[[
  Plug 'kassio/neoterm'
  let g:neoterm_default_mod='belowright' " open terminal in bottom split
  let g:neoterm_size=14                  " terminal split size
  let g:neoterm_autoscroll=1             " scroll to the bottom
  " nnoremap <Leader>rf :T ptipython<CR>
  " some modules do not work in ptpython
  nnoremap <Leader>rr :Tclear<CR>
  nnoremap <Leader>rt :Ttoggle<CR>
  nnoremap <Leader>ro :Ttoggle<CR> :Ttoggle<CR>
  "]]] === Neoterm ===

  " ============== Floaterm | lf | lazygit ============== [[[
  Plug 'ptzz/lf.vim'
  Plug 'voldikss/vim-floaterm'
  Plug 'voldikss/fzf-floaterm'
  nnoremap <Leader>fll :Floaterms<CR>
  nnoremap <Leader>flt :FloatermToggle<CR>
  let g:fzf_floaterm_newentries = {
        \ '+lazygit' : {
        \ 'title': 'lazygit',
        \ 'height': 0.9,
        \ 'width': 0.9,
        \ 'cmd' : 'lazygit' },
        \ '+gitui' : {
        \ 'title': 'gitui',
        \ 'height': 0.9,
        \ 'width': 0.9,
        \ 'cmd' : 'gitui' },
        \ '+taskwarrior-tui' : {
        \ 'title': 'taskwarrior-tui',
        \ 'height': 0.99,
        \ 'width': 0.99,
        \ 'cmd' : 'taskwarrior-tui' },
        \ '+flf' : {
        \ 'title': 'full screen lf',
        \ 'height': 0.9,
        \ 'width': 0.9,
        \ 'cmd' : 'lf' },
        \ '+slf' : {
        \ 'title': 'split screen lf',
        \ 'wintype': 'split',
        \ 'height': 0.5,
        \ 'cmd' : 'lf' },
        \ '+xplr' : {
        \ 'title': 'xplr',
        \ 'cmd' : 'xplr' },
        \ '+gpg-tui' : {
        \ 'title': 'gpg-tui',
        \ 'height': 0.9,
        \ 'width': 0.9,
        \ 'cmd': 'gpg-tui'},
        \ '+tokei' : {
        \ 'title': 'tokei',
        \ 'height': 0.9,
        \ 'width': 0.9,
        \ 'cmd': 'tokei'},
        \ '+dust' : {
        \ 'title': 'dust',
        \ 'height': 0.9,
        \ 'width': 0.9,
        \ 'cmd': 'dust'},
        \}
  let g:floaterm_shell = 'zsh'
  let g:floaterm_wintype = 'float'
  let g:floaterm_height=0.8
  let g:floaterm_width=0.8
  " Stackoverflow helper
  nmap <Leader>so : FloatermNew --autoclose=0 so<space>

  let g:lf_map_keys = 0
  let g:lf_replace_netrw = 1
  nnoremap <Leader>lf :Lf<CR>
  nnoremap <M-o> :Lf<CR>
  " ]]]  === Floaterm | lf ===

  " ============ coc-nvim ============ [[[
  " Plug 'tjdevries/coc-zsh'
  Plug 'vim-perl/vim-perl', { 'for': 'perl' }
  Plug 'neoclide/coc.nvim', {'branch': 'master', 'do': 'yarn install --frozen-lockfile'}
  Plug 'antoinemadec/coc-fzf'
  " ]]] === coc-nvim ===

  " ============== vim-slime | python ============== [[[
  if !empty(glob('$XDG_DATA_HOME/pyenv/shims/python3'))
    let g:python3_host_prog = glob('$XDG_DATA_HOME/pyenv/shims/python')
  endif
  " ]]] === vim-slime | python ===

  " ============== vim-rust ============== [[[
  Plug 'nastevens/vim-cargo-make'
  Plug 'rust-lang/rust.vim', { 'for': 'rust' }
  " FIX: visual selection
  " \ nmap     <buffer> <Leader>d<CR> :VT cargo play $(pwd)/**.rs<CR>|
  " Trying to decide which one is the best (play, eval, rust-script)
  augroup rust_env
    autocmd!
    autocmd FileType rust
          \ nmap     <buffer> <Leader>h<CR> :VT cargo clippy<CR>|
          \ nmap     <buffer> <Leader>n<CR> :VT cargo run   -q<CR>|
          \ nmap     <buffer> <Leader><Leader>n :VT cargo run -q<space>|
          \ nmap     <buffer> <Leader>t<CR> :RustTest<CR>|
          \ nmap     <buffer> <Leader>b<CR> :VT cargo build -q<CR>|
          \ nmap     <buffer> <Leader>r<CR> :VT cargo play  %<CR>|
          \ nmap     <buffer> <Leader><Leader>r :VT cargo play % -- |
          \ nmap     <buffer> <Leader>v<CR> :VT rust-script %<CR>|
          \ nmap     <buffer> <Leader><Leader>v :VT rust-script % -- |
          \ nmap     <buffer> <Leader>e<CR> :VT cargo eval  %<CR>|
          \ vnoremap <a-f> <esc>`<O<esc>Sfn main() {<esc>`>o<esc>S}<esc>k$|
          \ nnoremap <Leader>K : set winblend=0 \| FloatermNew --autoclose=0 rusty-man --viewer tui<space>|
          \ nnoremap <Leader>k : set winblend=0 \| FloatermNew --autoclose=0 rusty-man <C-r><C-w> --viewer tui<CR>|
          \ nnoremap <buffer> ;ff           :RustFmt<cr>
  augroup END
  " \ nnoremap ;k : set winblend=0 \| FloatermNew --autoclose=0 rusty-man <C-R>0<CR>|
  " ]]] === vim-rust ===

  " ================ zig ================= [[[
  augroup zig_env
    autocmd!
    autocmd FileType zig
          \ nnoremap <Leader>r<CR> : FloatermNew --autoclose=0 zig run ./%<CR>|
          \ nnoremap <buffer> ;ff           :Format<cr>
  augroup END
  " ]]] === zig ===

  " ============== vim-go ============== [[[
  Plug 'fatih/vim-go', { 'for': 'go' }
  " run and view go output in floating or split window
  function! s:run_go(...)
    if filereadable(expand("%:r"))
      call delete(expand("%:r"))
    endif
    write
    let arg = get(a:, 1, 0)
    if arg == "split"
      execute 'FloatermNew --autoclose=0 --wintype=vsplit --width=0.5 '
            \ . ' go build ./% && ./%:r'
    elseif arg == "float"
      execute 'FloatermNew --autoclose=0 go build ./% && ./%:r'
    endif
  endfunction
  command! GORUNS :call s:run_go("split")
  command! GORUN :call s:run_go("float")
  augroup GoRunCust
    autocmd!
    autocmd FileType go nnoremap <Leader>rv :GORUNS<CR>
    autocmd FileType go nnoremap <Leader>ru :GORUN<CR>
  augroup END
  " au FileType go nmap <Leader>rp <Plug>(go-run)
  " au FileType go nmap <Leader>rv <Plug>(go-run-vertical)

  function! s:build_go_files()
    let l:file = expand('%')
    if l:file =~# '^\f\+_test\.go$'
      call go#test#Test(0, 1)
    elseif l:file =~# '^\f\+\.go$'
      call go#cmd#Build(0)
    endif
  endfunction

  augroup go_env
    autocmd!
    " Note: Do not change the order!
    " Note: Do not comment lines inplace
    " nmap <buffer> <Leader>K <Plug>(go-doc)|
    " let g:go_doc_popup_window = 1
    let g:go_rename_command = 'gopls'
    autocmd FileType go
          \ setl nolist|
          \ nmap <buffer> <Leader>b<CR> :call <SID>build_go_files()<CR>|
          \ nmap <buffer> <Leader>r<CR> <Plug>(go-run)|
          \ nmap <buffer> <Leader>rr    :GoRun %<CR>|
          \ nmap <buffer> <Leader>ri    :GoRun %<space>|
          \ nmap <buffer> <Leader>t<CR> <Plug>(go-test)|
          \ nmap <buffer> <Leader>c<CR> <Plug>(go-coverage-toggle)|
          \ nmap <buffer> <Leader>gae <Plug>(go-alternate-edit)|
          \ nmap <buffer> <Leader>i <Plug>(go-info)|
          \ nmap <buffer> <Leader>sm :GoSameIdsToggle<CR>|
          \ nmap <buffer> <C-A-n> :cnext<CR>|
          \ nmap <buffer> <C-A-m> :cprevious<CR>|
          \ nmap <buffer> <Leader>f :GoDeclsDir<cr>|
          \ nmap <buffer> ;ff :GoFmt<CR>|
          \ let g:go_fmt_command = "goimports"|
          \ let g:go_list_type = "quickfix"|
          \ let g:go_highlight_types = 1|
          \ let g:go_highlight_fields = 1|
          \ let g:go_highlight_functions = 1|
          \ let g:go_highlight_methods = 1|
          \ let g:go_highlight_operators = 1|
          \ let g:go_highlight_build_constraints = 1|
          \ let g:go_highlight_generate_tags = 1|
          \ let g:go_gocode_propose_builtins = 1|
          \ let g:go_gocode_unimported_packages = 1|
          \ let g:go_doc_keywordprg_enabled = 0|
          \ let g:go_fmt_fail_silently = 1|
          \ command! -bang A call go#alternate#Switch(<bang>0, 'edit')|
          \ command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')|
          \ command! -bang AS call go#alternate#Switch(<bang>0, 'split')|
          "\ let g:go_auto_type_info = 1|
          "\ let g:go_updatetime = 100|
          "\ let g:go_auto_sameids = 1|
          "\ let g:go_play_open_browser = 1|
  augroup END
  " ]]] === vim-go ===

  nnoremap <Leader>mcs :vs ~/vimwiki/dotfiles/mkdx.md<CR>
  nnoremap <Leader>mdm :menu Plugin.mkdx<CR>
  nnoremap <Leader>ec :e ~/.config/nvim/coc-settings.json<CR>
  nnoremap <Leader>ev :e $VIMRC<CR>
  nnoremap <Leader>sv :so $VIMRC<CR>
  nnoremap <Leader>ez :e $ZDOTDIR/.zshrc<CR>

  " ============== UltiSnips ============== [[[
  " Plug 'SirVer/ultisnips'
  " Plug 'honza/vim-snippets'
  " let g:UltiSnipsExpandTrigger='<C-S-1>'
  " let g:UltiSnipsJumpForwardTrigger='<C-j>'
  " let g:UltiSnipsJumpBackwardTrigger='<C-k>'
  " let g:UltiSnipsListSnippets="<C-u>"
  " let g:UltiSnipsEditSplit='horizontal'

  " Plug 'vim-scripts/RltvNmbr.vim'
  " nmap <Leader>rl :RltvNmbr<CR>

  " ]]] ==== UltiSnips ===

  " ========= Syntax Highlighting ======== [[[
  Plug 'sheerun/vim-polyglot'
  let g:polyglot_disabled = ['markdown', 'python', 'rust', 'java', 'lua', 'ruby', 'zig', 'just']
  " Plug 'wfxr/dockerfile.vim'  | let g:polyglot_disabled += ['dockerfile']
  " Plug 'rhysd/vim-rustpeg'    | let g:polyglot_disabled += ['rustpeg']
  " Plug 'camnw/lf-vim'         | let g:polyglot_disabled += ['lf']
  " Plug 'ron-rs/ron.vim'       | let g:polyglot_disabled += ['ron']
  " Plug 'mattn/vim-xxdcursor'  | Plug 'fidian/hexmode'     | let g:hexmode_patterns = '*.o,*.so,*.a,*.out,*.bin,*.exe'
  " Plug 'jamessan/vim-gnupg'

  "]]] === Syntax Highlighting ===

  Plug 'gelguy/wilder.nvim', { 'do': ':UpdateRemotePlugins' }
  Plug 'roxma/nvim-yarp'
  Plug 'roxma/vim-hug-neovim-rpc'

  " ============== Themes ============== [[[
  " Plug 'morhetz/gruvbox'
  " Plug 'gavinok/spaceway.vim'
  Plug 'sainnhe/gruvbox-material'
  Plug 'sainnhe/edge'
  Plug 'sainnhe/everforest'
  Plug 'sainnhe/sonokai'
  Plug 'marko-cerovac/material.nvim'
  " ]]] === Themes ===

  call plug#end() " ]]]

  " ============== Theme Settings ============== [[[
  " let g:gruvbox_material_background = 'medium'
  let g:gruvbox_material_palette = 'mix'
  " let g:gruvbox_material_palette = 'material'
  let g:gruvbox_material_background = 'hard'
  let g:gruvbox_material_enable_bold = 1
  let g:gruvbox_material_disable_italic_comment = 1
  let g:gruvbox_material_current_word = 'grey background'
  let g:gruvbox_material_visual = 'grey background'
  let g:gruvbox_material_cursor = 'green'
  let g:gruvbox_material_sign_column_background = 'none'
  let g:gruvbox_material_statusline_style = 'mix'
  let g:gruvbox_material_better_performance = 1
  let g:gruvbox_material_diagnostic_text_highlight = 0
  let g:gruvbox_material_diagnostic_line_highlight = 0
  let g:gruvbox_material_diagnostic_virtual_text = 'colored'

  let g:overcast_allow_bold = 1

  let g:oceanic_material_background = "ocean"
  " let g:oceanic_material_background = "deep"
  " let g:oceanic_material_background = "medium"
  " let g:oceanic_material_background = "darker"
  let g:oceanic_material_allow_bold = 1
  let g:oceanic_material_allow_italic = 1
  let g:oceanic_material_allow_underline = 1

  let g:everforest_disable_italic_comment = 1
  let g:everforest_background = 'hard'
  let g:everforest_enable_italic = 0
  let g:everforest_sign_column_background = 'none'
  let g:everforest_better_performance = 1

  let g:edge_style = 'aura'
  let g:edge_cursor = 'blue'
  let g:edge_sign_column_background = 'none'
  let g:edge_better_performance = 1

  " let g:material_theme_style = 'darker-community'
  let g:material_theme_style = 'ocean-community'
  let g:material_terminal_italics = 1

  " maia atlantis era
  " let g:sonokai_style = 'andromeda'
  let g:sonokai_style = 'shusia'
  let g:sonokai_enable_italic = 1
  let g:sonokai_disable_italic_comment = 1
  let g:sonokai_cursor = 'blue'
  let g:sonokai_sign_column_background = 'none'
  let g:sonokai_better_performance = 1
  let g:sonokai_diagnostic_text_highlight = 0

  " let g:miramare_enable_italic = 1
  let g:miramare_enable_bold = 1
  let g:miramare_disable_italic_comment = 1
  let g:miramare_cursor = 'purple'
  let g:miramare_current_word = 'grey background'

  let g:gruvbox_contrast_dark = 'medium'
  let g:spacegray_use_italics = 1

  syntax enable
  colorscheme gruvbox-material
  " colorscheme overcast
  " colorscheme serenade
  " colorscheme everforest
  " colorscheme gruvbox-material
  " colorscheme sonokai
  " colorscheme oceanic_material
  " colorscheme spaceduck
  " colorscheme bogster
  " colorscheme material
  " colorscheme miramare
  " colorscheme night-owl
  " colorscheme jellybeans
  " colorscheme deep-space
  " colorscheme melange
  " colorscheme iceberg
  " coloscheme OceanicNext
  " colorscheme deus
  " colorscheme onedark
  " colorscheme neodark
  " colorscheme spaceway    " needs work
  " colorscheme alduin      " needs work
  " colorscheme spacegray
  " colorscheme tokyonight

  " colorscheme material
  " edge daycula srcery dogrun palenight

  " ]]] === Theme Settings ===

  if has("autocmd")
    " Restore cursor position when opening buffer
    augroup lmb__RestoreCursor
      autocmd!
      autocmd BufReadPost *
            \ if line("'\"") > 1 && line("'\"") <= line("$") |
            \     exe 'norm! g`"zvzz' |
            \ endif
    augroup END
  endif

  call plugs#fzf#setup()
  call plugs#coc#setup()

  call usr#core#commands#setup()
  if has("autocmd")
    call usr#core#autocmds#setup()
  endif

  " ============== General Mappings ============== [[[
  nnoremap q: <Nop>
  nnoremap q/ <Nop>
  nnoremap q? <Nop>

  cnoreabbrev W! w!
  cnoreabbrev Q! q!
  cnoreabbrev Qall! qall!
  cnoreabbrev Wq wq
  cnoreabbrev Wa wa
  cnoreabbrev wQ wq
  cnoreabbrev WQ wq
  cnoreabbrev W w
  cnoreabbrev Qall qall

  " === Insert ============================================================== [[[

  " Go beginning of line
  inoremap <M-S-"> <Home>
  " Go end of line
  inoremap <M-'> <End>
  " Go word back
  inoremap <M-b> <C-Left>
  " Go word forward
  inoremap <M-f> <C-Right>
  " Go word back
  inoremap <C-S-h> <C-Left>
  " Go word forward
  inoremap <C-S-l> <C-Right>
  " Go one char left
  inoremap <C-S-n> <Left>
  " Go one char right
  " Go one line up
  inoremap <C-S-k> <C-o>gk
  " Go one line down
  inoremap <C-S-j> <C-o>gj
  " Goto next screen-line
  inoremap <Down> <C-o>gj
  " Goto prev screen-line
  inoremap <Up> <C-o>gk
  " Insert last inserted text
  inoremap <M-/> <C-a>
  " Paste
  inoremap <C-S-p> <C-o>p
  " Paste formatted
  imap <C-M-p> <C-o>ghp
  " Paste formatted
  imap <C-M-,> <C-o>ghp
  " Paste commented
  imap <M-p> <C-o>g2p
  " Paste commented
  imap <C-M-.> <C-o>g2p
  " Command mode
  inoremap <C-n> <C-o>:

  inoremap , ,<C-g>u
  inoremap . .<C-g>u
  inoremap ! !<C-g>u
  inoremap ? ?<C-g>u
  " inoremap <CR> <CR><C-g>u
  " Start new undo sequence
  inoremap <C-S-u> <C-g>u
  " Start new undo sequence
  inoremap <C-/> <C-g>u
  " Undo typed text
  inoremap <C-o>u <C-g>u<C-o>u
  " Redo
  inoremap <C-o>U <C-g>u<C-o><C-r>
  " Undo typed text
  inoremap <M-u> <C-g>u<C-o>u
  " Redo
  inoremap <M-S-u> <C-g>u<C-o><C-r>
  " Delete previous word
  inoremap <M-BS> <C-g>u<C-w>
  " Delete all typed in insert (before cursor)
  inoremap <C-u> <C-g>u<C-u>
  " Delete character to right
  inoremap <C-l> <C-g>u<Del>
  " Delete to end of word
  inoremap <M-d> <C-g>u<C-o>de
  " Left kill line
  inoremap <M-[> <C-g>u<C-o>dg^
  " Right kill line
  inoremap <M-]> <C-g>u<C-o>dg$
  " Right kill line
  inoremap <M-,> <C-g>u<C-o>dg$
  " Kill whole line
  inoremap <M-x> <C-g>u<C-o>cc

  " Equivalent: 'norm! o'
  inoremap <M-o> <C-g>u<C-o>o
  " Equivalent: 'norm! o'
  inoremap <M-CR> <C-g>u<C-o>o
  " Move current line down
  inoremap <M-i> <C-g>u<C-o>O
  " Move current line down
  inoremap <M-S-o> <C-g>u<C-o>O
  " Insert line above
  imap <C-M-i> <C-g>u<C-o>zk
  " Insert line below
  imap <C-M-o> <C-g>u<C-o>zj
  " Fix last spelling mistake
  inoremap <M-s> <C-g>u<Esc>[s1z=`]a<C-g>u

  " Insert file name
  inoremap <F1> <C-R>=expand('%')<CR>
  " Insert directory
  inoremap <F2> <C-R>=expand('%:p:h')<CR>
  " ]]]

  " === Command ============================================================= [[[
  " ]]]

  " === Normal ============================================================= [[[
  nnoremap ;q :q<CR>
  nnoremap <silent> ;w :update<CR>
  nnoremap <BS> <C-^>

  nnoremap - "_
  xnoremap - "_
  " Remap mark jumping
  noremap ' `
  noremap ` '

  " Repeat last command
  nnoremap <F2> @:
  xnoremap <F2> @:
  nnoremap <Leader>r. @:
  xnoremap <Leader>r. @:

  " use qq to record, q to stop, Q to play a macro
  nnoremap Q @q
  xnoremap Q :normal @q
  nnoremap <expr> qq (reg_recording() ==# '') ? 'qq' : 'q'
  nnoremap <expr> ql (reg_recording() ==# '') ? 'ql' : 'q'

  " nnoremap <expr> qq
  "       \ (v:register ==# '"') ? 'q' :
  "       \ (':let @'..(empty(reg_recorded()) ? 'q'
  "       \   : reg_recorded()).." = '<C-R>=substitute(@".v:register.",\"'\",\"''\",\"g\")<CR>'<C-F>010l")
  " Replay @q for each line of the visual selection.
  " xnoremap Q :normal @<c-r>=reg_recorded()<cr><cr>
  "
  " Perform dot commands over visual blocks
  xnoremap . :normal .<CR>

  " TODO: Differentiate with shift mappings
  " nnoremap U <C-r>
  nmap . <Plug>(RepeatDot)
  nmap u <Plug>(RepeatUndo)
  nmap U <Plug>(RepeatRedo)
  " nmap <C-S-u> <Plug>(RepeatUndoLine)

  " Go to newer text state
  nnoremap ;U <Cmd>execute('later ' . v:count1 . 'f')<CR>
  " Go to older state
  nnoremap ;u <Cmd>execute('earlier ' . v:count1 . 'f')<CR>

  " inserts a line above or below
  nnoremap <silent> zj :call append(line('.') + v:count, '')<CR>
  nnoremap <silent> zk :call append(line('.') - v:count1, '')<CR>
  " keep focused in center of screen when searching
  nnoremap <expr> n (v:searchforward ? 'nzzzv' : 'Nzzzv')
  nnoremap <expr> N (v:searchforward ? 'Nzzzv' : 'nzzzv')
  " move through folded lines
  nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
  nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'
  xnoremap j    gj
  xnoremap k    gk
  nnoremap gj   j
  xnoremap gj   j
  nnoremap gk   k
  xnoremap gk   k
  nnoremap H    g^
  xnoremap H    g^
  onoremap H    g^
  nnoremap <expr> L (v:count > 0 ? '@_1g_' : 'g$'.(getline('.')[strlen(getline('.'))-1] == ' ' ? 'ge' : ''))
  xnoremap L    g_
  onoremap L    g$
  " xnoremap L    :norm! g$<CR><Cmd>exe (getline('.')[col('.')] == ' ' ? 'norm! ge' : '')<CR>

  nnoremap <Down> }
  nnoremap <Up>   {
  nnoremap <expr> 0 (getline('.')[0:col('.')-2] =~# '^\s\+$' ? 'g0' : 'm`g^')

    " move selected text up down
    " TODO: get these mappings to work
    " nnoremap <C-S-j> :m .+1<CR>==
    " nnoremap <C-S-k> :m .-2<CR>==
    xnoremap J :m '>+1<CR>gv=gv
    xnoremap K :m '<-2<CR>gv=gv
    inoremap <C-j> <Esc>:m .+1<CR>==gi
    inoremap <C-k> <Esc>:m .-2<CR>==gi
    " inoremap <C-j> <Esc>:m .+1<CR>==a
    " inoremap <C-k> <Esc>:m .-2<CR>==a

    " don't lose selection when shifting sidewards
    xnoremap < <gv
    xnoremap > >gv

    " Delete blackhole
    nnoremap d "_d
    xnoremap d "_d
    " Delete to end of line (blackhole)
    nnoremap D "_D
    " Delete line (blackhole)
    nnoremap S ^"_D
    " Cut letter (blackhole)
    nnoremap x "_x
    " Yank to EOL (without newline)
    nnoremap Y y$
    " Place the cursor at end of yank
    xnoremap y ygv<Esc>
    " Select entire line (without newline)
    nnoremap vv ^vg_
    " Select entire file
    nnoremap <M-a> VggoG
    " paste over selected text
    xnoremap p "_c<Esc>p
    " reselect the text that has just been pasted
    nnoremap <expr> gV '`[' . strpart(getregtype(), 0, 1) . '`]'
    " nnoremap gV `[v`]

    " Goto last insert spot
    nnoremap gI `^
    " Get ASCII value
    nnoremap gA ga
    " Show buffer info
    nnoremap <C-g> 2<C-g>
    " Show word count
    xnoremap <C-g> g<C-g>

    " TODO:
    " Yank directory
    " nnoremap yd :call YankReg(v:register, expand('%:p:h'))<CR>
    " Yank file name
    " nnoremap yn :call YankReg(v:register, expand('%:t'))<CR>
    " Yank full path
    " nnoremap yP :call YankReg(v:register, expand('%:p'))<CR>
    " Yank motion
    " nnoremap y :call YankWrap()<CR>
    " nmap yw :call YankWrap('iw')<CR>
    " nmap yW :call YankWrap('iW')<CR>
    " nmap yl :call YankWrap('aL')<CR>
    " nmap yL :call YankWrap('iL')<CR>
    " nmap yu :call YankWrap('au')<CR>
    " nmap yh :call YankWrap('ai')<CR>
    " nmap yp :call YankWrap('ip')<CR>
    " nmap yo :call YankWrap('iss')<CR>
    " nmap yO :call YankWrap('ass')<CR>
    " nmap yq :call YankWrap('iq')<CR>
    " nmap yQ :call YankWrap('aq')<CR>

    nnoremap <expr> cc (getline('.') =~ '^\s*$' ? '"_cc' : 'cc')
    " cgn start `cword`
    nnoremap c* :let @/='\\<'.expand('<cword>').'\\>'<CR>cgn
    " Change text (dot repeatable)
    xnoremap C "cy:let @/=@c<CR>cgn
    " Change text; search forward
    nnoremap cn *``cgn
    " Change text; search backward
    nnoremap cN *``cgN
    " Last change init `cgn`
    nnoremap g. /\V<C-r>"<CR>cgn<C-a><Esc>

    " Replace under cursor
    nnoremap <Leader>sr :%s/\<<C-r><C-w>\>/
    " Global replace
    nnoremap <Leader>sg :%s//g<Left><Left>
    " Change all matches
    nnoremap cM :%s/<C-r>///g<Left><Left>
    " Delete all search matches
    nnoremap dM :%s/<C-r>//g<CR>

    " Search visible screen
    " nnoremap z/ /\%><C-r>=line("w0")-1<CR>l\%<<C-r>=line("w$")+1<CR>l
    nnoremap <silent> z/ :let old=&so<Bar>so=0<CR>m`HVL<Esc>:let &so=old<CR>``<C-y>/\%V
    " Search visual selection
    " xnoremap z/ <Esc>/\\%V
    xnoremap <silent> z/ :<C-U>call usr#fn#range_search('/')<CR>:if strlen(g:srchstr) > 0\|exec '/'.g:srchstr\|endif<CR>
    xnoremap <silent> z? :<C-U>call usr#fn#range_search('?')<CR>:if strlen(g:srchstr) > 0\|exec '?'.g:srchstr\|endif<CR>
    " Search for visual selection
    xnoremap g/ y/<C-R>"<CR>

    " Join lines & remove backslash
    nnoremap <silent><expr> gW (getline('.')[strlen(getline('.'))-1] == '\' ? '$xJ' : 'J')

    " Move cursor to center of line
    nnoremap <expr> gM (virtcol('$') / 2) . '<Bar>'
    " Clear highlight
    nnoremap <silent> <Esc> :nohlsearch<CR>:call clearmatches()<CR>

    nnoremap <Leader>sv :source $MYVIMRC<CR>
    nnoremap <Leader>ev :e $MYVIMRC<CR>

    nnoremap <Leader>b. :ls!<CR>
    nnoremap <Leader>ls :ls!<CR>
    " nnoremap <Leader>c; :let &mouse=(empty(&mouse) ? 'a' : '')<CR>
    nnoremap <silent><Leader>co :set cursorcolumn! cursorcolumn?<CR>
    nnoremap <silent><Leader>c; :exec "set formatoptions"..(stridx(&formatoptions, 'r') == -1 ? "+=ro" : "-=ro").." formatoptions?"<CR>
    nnoremap <silent><Leader>ci :exec "set stal="..(&stal == 2 ? "0" : "2").." stal?"<CR>
    nnoremap <silent><Leader>cv :exec "set cole="..(&cole == 2 ? "0" : "2").." cole?"<CR>

    nnoremap <Leader>a; :h pattern-overview<CR>
    nnoremap <Leader>am :h index<CR>
    nnoremap <Leader>ab :h builtin<CR>
    nnoremap <Leader>ae :h ex-commands<CR>
    nnoremap <Leader>aQ :h quickref<CR>
    nnoremap <Leader>aa :h Q_fl<CR>
    nnoremap <Leader>au :h Q_bu<CR>
    nnoremap <Leader>aw :h Q_wi<CR>
    nnoremap <Leader>af :h Q_fo<CR>
    nnoremap <Leader>ac :h Q_ce<CR>
    nnoremap <Leader>aq :h Q_qf<CR>
    nnoremap <Leader>ao :h Q_op<CR>

    nnoremap <Leader>rt :setl et<CR>
    nnoremap <Leader>re :setl et<CR><Cmd>retab<CR>
    xnoremap <Leader>re :retab<CR>
    nnoremap <Leader>cd :lcd %:p:h<CR><Cmd>pwd<CR>
    "]]]

    " === Visual ============================================================= [[[
    " Delete (blackhole)
    xnoremap d "_d
    " Place the cursor at end of yank
    xnoremap y ygv<Esc>
    " Show word count
    xnoremap <C-g> g<C-g>
    " Repeat last substitution
    xnoremap & :&&<CR>
    " ]]]

    " === Folds =============================================================== [[[
    " Refocus folds
    nmap <LocalLeader>z zMzvzz
    " Center or top current line
    nnoremap <expr> zz (winline() == (winheight(0)+1)/2) ? 'zt' : (winline()==1) ? 'zb' : 'zz'

    " Toggle fold
    nnoremap <expr><silent> z; ((foldclosed('.') < 0) ? 'zc' : 'zo')
    " Toggle all folds
    nnoremap <expr><silent> z' ((foldclosed('.') < 0) ? 'zM' : 'zR')
    " Toggle one/all folds under cursor
    nnoremap <expr><silent> zy ((foldclosed('.') < 0) ? 'zA' : 'za')

    " Inside foldblock
    xnoremap iz <Cmd>keepj norm [zjo]zkL<CR>
    " Inside foldblock
    onoremap iz :norm viz<CR>
    " Around foldblock
    xnoremap az <Cmd>keepj norm [zo]zjLV<CR>
    " Around foldblock
    onoremap az :norm vaz<CR>

    " Top open fold (foldlvls)
    nnoremap <silent> [z [z_
    xnoremap <silent> [z [z_
    " Bottom open fold (foldlvls)
    nnoremap <silent> ]z ]z_
    xnoremap <silent> ]z ]z_
    " Next fold start
    nnoremap <silent> z] zj_
    xnoremap <silent> z] zj_
    " Prev fold bottom
    nnoremap <silent> z[ zk_
    xnoremap <silent> z[ zk_
    " Next fold start
    nnoremap <silent> zl zj_
    xnoremap <silent> zl zj_
    " Prev fold start
    " nnoremap <silent> zl ufo.goPreviousStartFold
    " xnoremap <silent> zl ufo.goPreviousStartFold
    " Next closed fold
    " nnoremap <silent> z. ufo.goNextClosedFold
    " xnoremap <silent> z. ufo.goNextClosedFold
    " Prev closed fold
    " nnoremap <silent> z, ufo.goPreviousClosedFold
    " xnoremap <silent> z, ufo.goPreviousClosedFold
    " Close folds with v:count
    " nnoremap <silent> zK ufo.closeFoldsWith
    " xnoremap <silent> zK ufo.closeFoldsWith
    " " Open all folds (keep 'fdl')
    " nnoremap <silent> zR ufo.openAllFolds
    " xnoremap <silent> zR ufo.openAllFolds
    " Close all folds (keep 'fdl')
    " nnoremap <silent> zM ufo.closeAllFolds
    " xnoremap <silent> zM ufo.closeAllFolds
    " ]]]

    " === Windows ============================================================= [[[
    " move between windows
    nnoremap <C-j> <C-W>j
    nnoremap <C-k> <C-W>k
    nnoremap <C-h> <C-W>h
    nnoremap <C-l> <C-W>l
    " Change vertical to horizontal
    nnoremap <C-w><lt> <C-w>t<C-w>K
    " Change horizontal to vertical
    nnoremap <C-w>> <C-w>t<C-w>H
    " Open curwin in tab
    nnoremap <C-w>T <Cmd>tab sp<CR>
    " Close all tabs except current
    nnoremap <C-w>O <Cmd>tabo<CR>
    " Equally high and wide
    nnoremap <C-w>0 <C-w>=

    " === Quickfix =========================================================== [[[
    " Prev item
    nmap [q :execute(v:count1 . 'cprev')<CR>
    " Next item
    nmap ]q :execute(v:count1 . 'cnext')<CR>
    " First item
    nmap [Q :cfirst<CR>
    " Last item
    nmap ]Q :clast<CR>
    " Prev quickfix list
    nmap [e :colder<CR>
    " Next quickfix list
    nmap ]e :cnewer<CR>
    " Goto prev file
    nmap qp :cpfile<CR>
    " Goto next file
    nmap qn :cnfile<CR>
    " View error
    nmap qi :cc<CR>
    " Close quickfix
    " nnoremap qc qf.close
    " ]]]
    " === Loclist ============================================================ [[[
    " Open loclist
    nmap qw :lopen<CR>
    " Prev item
    nmap [w :execute(v:count1 . 'lprev')<CR>
    " Next item
    nmap ]w :execute(v:count1 . 'lnext')<CR>
    " First item
    nmap [W lfirst
    " Last item
    nmap ]W llast
    " Prev loclist
    nmap [E lolder
    " Next loclist
    nmap ]E lnewer
    " ]]]
    " === Tab ================================================================ [[[
    " Prev tab
    nmap [t tabp
    " Next tab
    nmap ]t tabn
    " Close tab
    nmap qt tabc
    " ]]]
    " === Buffer ============================================================= [[[
    " Buffer switching
    " nnoremap gt :bnext<CR>
    " nnoremap gT :bprevious<CR>
    nnoremap <C-S-Right> :bnext<CR>
    nnoremap <C-S-Left> :bprevious<CR>
    " New buffer
    nnoremap <Leader>bn :enew<cr>
    " Close buffer
    nnoremap <Leader>bq :bp <bar> bd! #<cr>
    " Close all buffers
    nnoremap <Leader>bQ :bufdo bd! #<cr>
    " ]]]
    " ]]]

    " === SpellCheck ========================================================== [[[
    noremap <Leader>ss :setlocal spell!<CR>
    noremap <Leader>sn ]s
    noremap <Leader>sp [s
    noremap <Leader>sa zg
    noremap <Leader>s? z=
    noremap <Leader>su zuw
    " Spell: correct next
    nnoremap <Leader>sl <c-g>u<Esc>[s1z=`]a<c-g>u
    " ]]] === Spell Check ===

    " xnoremap @ macro_visual
    " xnoremap . dot_visual
    " nnoremap <C-,>,
    " nnoremap <C-,>.

    nnoremap <Leader>ha :call s:DiffSaved<CR>

    nmap <Leader>mlm :marks<CR>
    nmap <Leader>mfd :delm! | delm A-Z0-9<CR>
    nmap <Leader>mld :delmarks a-z<CR>

    onoremap ie <Cmd>execute "norm! m`"<Bar>keepj norm! ggVG<CR>
    xnoremap ie :normal! ggVG"<CR>
    onoremap ae :<C-u>normal! HVL"<CR>
    xnoremap ae :normal! HVL"<CR>

    map <C-Up> :resize +1<CR>
    map <C-Down> :resize -1<CR>
    map <C-Right> :vertical resize +1<CR>
    map <C-Left> :vertical resize -1<CR>

    if has('vim_starting')
      nnoremap <unique> <C-,>; :call usr#fn#ToggleLastChar(';')<CR>
      nnoremap <unique> <C-,>: :call usr#fn#ToggleLastChar(':')<CR>
      nnoremap <unique> <C-,>, :call usr#fn#ToggleLastChar(',')<CR>
      nnoremap <unique> <C-,>. :call usr#fn#ToggleLastChar('.')<CR>
      nnoremap <unique> <C-,>qa :call usr#fn#ToggleLastChar('  # noqa')<CR>
    endif
    " ]]] === General Mappings ===

    " ============== Syntax ============== [[[
    map <F9> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
          \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
          \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

    nmap <silent> <Leader>sH :call usr#fn#synstack()<CR>
    nmap <silent> <Leader>sh :call usr#fn#syntax_query()<CR>
    nmap <Leader>sll :syn list
    nmap <Leader>slo :verbose hi

    " === custom syntax groups ===
    " \ cmTitle /\v(#|--|\/\/|\%)\s*\u\w*(\s+\u\w*)*:/
    " FIX: allow punctuation
    augroup ccommtitle
      autocmd!
      autocmd Syntax * syn match
            \ cmTitle /\v(#|--|\/\/|\%)\s*(\u\w*|\=+)(\s+\u\w*)*(:|\s*\w*\s*\=+)/
            \ contained containedin=.*Comment,vimCommentTitle,rustCommentLine
      autocmd Syntax * syn match myTodo
            \ /\v(#|--|\/\/|")\s(FIXME|FIX|DISCOVER|NOTE|NOTES|INFO|OPTIMIZE|XXX|EXPLAIN|TODO|CHECK|HACK|BUG|BUGS):/
            \ contained containedin=.*Comment.*,vimCommentTitle
      " perlLabel
      autocmd Syntax * syn keyword cmTitle contained=Comment
      autocmd Syntax * syn keyword myTodo contained=Comment
    augroup END
    " hi def link cmLineComment Comment
    hi def link cmTitle vimCommentTitle
    hi def link myTodo Todo
    " ]]] === Syntax ===

    " ============== wilder.nvim ============== [[[
    function! s:shouldDisable(x)
      let l:cmd = wilder#cmdline#parse(a:x).cmd
      return l:cmd ==# 'Man' || a:x =~# 'Git fetch origin '
    endfunction

    call wilder#enable_cmdline_enter()
    " cmap <expr> <Tab> wilder#in_context() ? wilder#next() : "\<Tab>"
    " cmap <expr> <S-Tab> wilder#in_context() ? wilder#previous() : "\<S-Tab>"

    call wilder#setup({
          \ 'modes': [':', '/', '?'],
          \ 'next_key': '<Tab>',
          \ 'previous_key': '<S-Tab>',
          \ 'accept_key': '<M-,>',
          \ 'reject_key': '<M-.>',
          \ })

    call wilder#set_option('renderer', wilder#renderer_mux({
          \ ':': wilder#popupmenu_renderer(wilder#popupmenu_border_theme({
          \   'highlighter': wilder#basic_highlighter(),
          \   'border': 'rounded',
          \   'max_height': 15,
          \   'highlights': {
          \     'border': 'Normal',
          \     'default': 'Normal',
          \     'accent': wilder#make_hl(
          \       'PopupmenuAccent', 'Normal', [{}, {}, {'foreground': '#A06469'}]),
          \   },
          \   'left': [
          \     ' ', wilder#popupmenu_devicons(),
          \   ],
          \   'right': [
          \     ' ', wilder#popupmenu_scrollbar(),
          \   ],
          \ })),
          \
          \ '/': wilder#wildmenu_renderer({
          \   'highlighter': wilder#basic_highlighter(),
          \   'highlights': {
          \     'accent': wilder#make_hl(
          \       'WildmenuAccent', 'StatusLine', [{}, {}, {'foreground': '#A06469'}]),
          \   },
          \ }),
          \ }))

    call wilder#set_option('pipeline', [
          \  wilder#branch(
          \    [
          \      wilder#check({-> getcmdtype() ==# ':'}),
          \      {ctx, x -> s:shouldDisable(x) ? v:true : v:false},
          \    ],
          \    wilder#python_file_finder_pipeline({
          \      'file_command': {_, arg -> arg[0] ==# '.' ? ['rg', '--files', '--hidden'] : ['rg', '--files']},
          \      'dir_command':  {_, arg -> arg[0] ==# '.' ? ['fd', '-tf', '-H'] : ['fd', '-tf']},
          \      'filters': ['difflib_sorter'],
          \    }),
          \    wilder#cmdline_pipeline({
          \      'language': 'python',
          \      'set_pcre2_pattern': 1,
          \    }),
          \    wilder#python_search_pipeline({
          \      'pattern': wilder#python_fuzzy_pattern(),
          \      'sorter': wilder#python_difflib_sorter(),
          \      'engine': 're',
          \    }),
          \   ),
          \ ])

    " call wilder#set_option('renderer', wilder#popupmenu_renderer({
    "       \ 'highlighter': wilder#basic_highlighter(),
    "       \ 'highlights': {
    "       \     'accent': wilder#make_hl(
    "       \       'PopupmenuAccent', 'Normal', [{}, {}, {'foreground': '#A06469'}]),
    "       \ },
    "       \ }))
    " ]]] === wilder ===

    " ============== vim-clang ============== [[[
    autocmd FileType c nnoremap <Leader>r<CR> :FloatermNew --autoclose=0 gcc % -o %< && ./%< <CR>

    augroup cpp_env
      autocmd!
      autocmd FileType cpp
            \ nnoremap <Leader>r<CR> :FloatermNew --autoclose=0 g++ % -o %:r && ./%:r <CR>|
            \ nnoremap <buffer> <Leader>kk :Fcman<CR>
    augroup END

    function! s:FullCppMan()
      let old_isk = &iskeyword
      setl iskeyword+=:
      let str = expand("<cword>")
      let &l:iskeyword = old_isk
      execute 'Man ' . str
    endfunction
    command! Fcman :call s:FullCppMan()
    " ]]] === vim-clang ===

    " ============== Default Terminal ============== [[[
    command! -nargs=* TP botright sp | resize 20 | term <args>
    command! -nargs=* VT vsp | term <args>
    " noremap <A-i> :TP<cr>A

    let g:term_buf = 0
    let g:term_win = 0
    function! TermToggle(height)
      if win_gotoid(g:term_win)
        hide
      else
        botright new
        exec "resize " . a:height
        try
          exec "buffer " . g:term_buf
        catch
          call termopen("zsh", {"detach": 0})
          let g:term_buf = bufnr("")
          set nonumber
          set norelativenumber
          set signcolumn=no
        endtry
        startinsert!
        let g:term_win = win_getid()
      endif
    endfunction

    " Toggle terminal on/off (neovim)
    nnoremap <C-t> :call TermToggle(12)<CR>
    inoremap <C-t> <Esc>:call TermToggle(12)<CR>
    tnoremap <C-t> <C-\><C-n>:call TermToggle(12)<CR>

    " Terminal go back to normal mode
    tnoremap <Esc> <C-\><C-n>
    tnoremap :q! <C-\><C-n>:q!<CR>
    " ]]] === Default Terminal ===

    " ============== background transparent / colors ============== [[[
    " highlight TelescopeNormal         guibg=#000000
    " highlight TelescopeSelection      guifg=#FF9500 gui=bold
    " highlight TelescopeSelectionCaret guifg=#819C3B
    " highlight TelescopeMultiSelection guifg=#4C96A8
    " highlight TelescopeBorder         guifg=#A06469
    " highlight TelescopePromptBorder   guifg=#A06469
    " highlight TelescopeResultsBorder  guifg=#A06469
    " highlight TelescopePreviewBorder  guifg=#A06469
    " highlight TelescopeMatching       guifg=#FF5813
    " highlight TelescopePromptPrefix   guifg=#EF1D55

    highlight DiffAdd      ctermfg=white ctermbg=NONE guifg=#5F875F guibg=NONE
    highlight DiffChange   ctermfg=white ctermbg=NONE guifg=#5F5F87 guibg=NONE
    highlight DiffDelete   ctermfg=white ctermbg=NONE guifg=#cc6666 guibg=NONE
    highlight DiffText     cterm=bold ctermfg=white ctermbg=DarkRed

    " highlight HighlightedyankRegion ctermbg=Red   guibg=#A06469
    highlight GitBlameVirtualText   cterm=italic  ctermfg=245   gui=italic guifg=#665c54

    hi MatchParen guifg=#088649
    hi vimOperParen guifg=#088649
    hi vimSep guifg=#088649
    hi Delimiter guifg=#088649
    hi Operator guifg=#088649
    " ]]] === transparent ===

    " ============== Other Functions ============== [[[

    " go_github: open in browser [[[
    function! s:go_github()
      let s:repo = matchstr(expand('<cWORD>'), '\v[0-9A-Za-z\-\.\_]+/[0-9A-Za-z\-\.\_]+')
      if empty(s:repo)
        echo 'GoGithub: No repository found.'
      else
        let s:url = 'https://github.com/' . s:repo
        " call netrw#BrowseX(s:url, 0)
        call openbrowser#open(s:url)
        end
      endfunction

      augroup gogithub
        au!
        au FileType *vim,*bash,*tmux,zsh nnoremap <buffer> <silent> <leader><cr> :call <sid>go_github()<cr>
      augroup END

      " Sources neovim first
      command! PluginUpdate source $VIMRC | :PlugUpdate
      command! PluginClean  source $VIMRC | :PlugClean
      " ]]]

      " IndentSize: Change indent size depending on file type [[[
      function! <SID>IndentSize(amount)
        exe "setlocal expandtab"
              \ . " ts="  . a:amount
              \ . " sts=" . a:amount
      endfunction

      " Filetype specific indents
      autocmd FileType typescript nnoremap <Leader>r<CR> :FloatermNew tsc % && node %:r.js <CR>
      autocmd FileType javascript nnoremap <Leader>r<CR> :FloatermNew node % <CR>
      autocmd FileType markdown,json,javascript call <SID>IndentSize(4)
      autocmd BufRead,BufNewFile *.htm,*.html call <SID>IndentSize(2)
      " ]]] IndentSize

      " DiffSaved: Show diff since last save [[[
      function! s:DiffSaved()
        let filetype=&filetype
        diffthis
        vnew | r # | normal! 1Gdd
        diffthis
        exe 'setl bt=nofile bh=wipe nobl noswf ro ft=' . filetype
      endfunction
      command! DS call s:DiffSaved()
      " ]]] DiffSaved

      " ExecuteBuffer: execute current buffer === [[[ "
      function! s:execute_buffer()
        if !empty(expand('%'))
          write
          call system('chmod +x '.expand('%'))
          silent e
          vsplit | terminal ./%
        else
          echohl WarningMsg
          echo 'Save the file first'
          echohl None
        endif
      endfunction
      command! RUN :call s:execute_buffer()

      augroup ExecuteBuffer
        au!
        au FileType sh,bash,zsh,python,ruby,perl,lua nnoremap <Leader>r<CR> :RUN<cr>
        au FileType sh,bash,zsh,python,ruby,perl,lua nnoremap <Leader>lru
              \ :FloatermNew --autoclose=0 ./%<cr>
      augroup END
      " ]]] ExecuteBuffer

      " ============== tmux ============== [[[
      function! s:tmux_copy_mode_toggle()
        setlocal number!
        if &signcolumn ==? 'no'
          setlocal signcolumn=auto
        else
          setlocal signcolumn=no
        endif
      endfunction
      command! TmuxCopyModeToggle call s:tmux_copy_mode_toggle()

      if !has('gui_running') && empty(&t_ts)
        if len($TMUX)
          let &t_ts = "\e]2;"
          let &t_fs = "\007"
        elseif &term =~ "^screen.*"
          let &t_ts="\ek"
          let &t_fs="\e\\"
        endif
      endif

      if exists('$TMUX')
        augroup lmb__RenameTmux
          au!
          " call system('tmux set-window-option -t '.$TMUX_PANE.' -q automatic-rename off')
          " au BufEnter * if empty(&buftype) | call system('tmux rename-window '.expand('%:t:S')) | endif
          " au BufEnter * if empty(&buftype) | let &titlestring = '' . expand('%:t') | endif
          " au VimLeave * call system('tmux setw -g automatic-rename')
          au BufEnter * if empty(&buftype) | set titlestring=%(%m%)%(%{expand(\"%:~\")}%)
          " au BufReadPost,FileReadPost,BufNewFile *
          "       \ if empty(&buftype) | call system("tmux rename-window "..expand("%")) | endif
          au VimLeave * call system("tmux rename-window "..$HOST..fnamemodify($SHELL, ':t'))
        augroup END
      endif

      " ]]] === tmux ===

      " PreserveClipboard: Fixes clearing of clipboard when using copyq [[[
      if executable('xsel')
        function! PreserveClipboard()
          call system('xsel -ib', getreg('+'))
        endfunction
        function! PreserveClipboadAndSuspend()
          call PreserveClipboard()
          suspend
        endfunction
        augroup preserve_clipboard
          au!
          au VimLeave * call PreserveClipboard()
        augroup END
        nnoremap <silent> <c-z> :call PreserveClipboadAndSuspend()<cr>
        vnoremap <silent> <c-z> :<c-u>call PreserveClipboadAndSuspend()<cr>
      endif
      " ]]]
      "]]] === Other Functions ===

    " use tab and shift tab to indent and de-indent code
      nnoremap <C-i> <C-i>
      nnoremap <C-o> <C-o>
      nnoremap <Tab>   >>
      nnoremap <S-Tab> <<
      xnoremap <Tab>   >><Esc>gv
      xnoremap <S-Tab> <<<Esc>gv
