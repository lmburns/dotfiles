# ╭──────────────────────────────────────────────────────────╮
# │                     Basics / General                     │
# ╰──────────────────────────────────────────────────────────╯ [[[

# Comments may be found in functions like ${{}} or !{{}} to provide
# documention in the popup menu when pressing keybindings

set shell zsh
set shellopts '-euy'
set ifs "\n"
set filesep "\n"  # default already

set scrolloff 10      # space on top and bottom of screen
set icons on          # show icons next to files
set history on        # save history across sessions
set period 1          # interval to check for directory updates
set hidden on         # show hidden files by default
set incsearch o       # jump to first match after each keystroke in search
set incfilter o       # apply filter after each keystroke
set smartcase         # if capital letter then case sensitive
set dirfirst          # show directories before regular files
# set dirpreviews       # pass directories to the previewer script
set dircounts on      # show number of items in directory instead of size
set info "size"       # list directory information on the right
set sortby "natural"  # don't sort files in any special way
set preview on        # preview file on the right pane
set drawbox on        # draw a border around all panes
set ratios '1:2:3'    # ratio of pane widths
# set number on         # show number of items index in dir
# set globsearch        # search with globs

# * '%u' username
# * '%h' hostname
# * '%w' working directory
# * '%d' working directory with trailing path separator
# * '%f' file name
# * '%F' current filter
# * '%S' provide spacer for right alignment
#  Default:   "\033[32;1m%u@%h\033[0m:\033[34;1m%d\033[0m\033[1m%f\033[0m"

# \033[32;1m%u\033[0m
# \033[1;38;2;234;105;98m@\033[0m
# \033[1;38;2;76;150;168m%h\033[0m    # Alt: # \033[1;96m%h\033[0m
# \033[1;38;5;21m:\033[0m
# \033[34;1m%d\033[0m
# \033[1;38;2;42;176;116m%d\033[0m

# set cursorfmt="\033[4m"
# set cursorpreviewfmt="\033[4m"
# set cursorfmt="%s"
# set cursorpreviewfmt="%s"

set promptfmt "\033[32;1m%u\033[0m\033[1;38;2;234;105;98m@\033[0m\033[1;38;2;76;150;168m%h\033[0m\033[1;38;5;21m:\033[0m\033[1;38;2;42;176;116m%d\033[0m\033[1m%f\033[0m %F"
set tagfmt "\033[1;38;5;018m"
set errorfmt "\033[7;38;5;017m"

set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml:lost+found"
# set tempmarks 'abcdefghijklmnopqrstuvwxzy'
set tempmarks '1234567890'

# -- Previewer: custom
$lf -remote "send $id set previewer ${XDG_CONFIG_HOME}/lf/scope"
$lf -remote "send $id set cleaner ${XDG_CONFIG_HOME}/lf/scripts/cleaner"

# set previewer '~/.config/lf/scope'
# set cleaner '~/.config/lf/scripts/cleaner'

# -- Previewer: lfimg
# $lf -remote "send $id set previewer ${XDG_CONFIG_HOME}/lf/others/preview"
# $lf -remote "send $id set cleaner ${XDG_CONFIG_HOME}/lf/others/cleaner"

# -- Previewer: stpv
# set previewer stpv
# set cleaner stpvimgclr
# &stpvimg --listen $id
# ]]]

# ╭──────────────────────────────────────────────────────────╮
# │                 Environmental Variables                  │
# ╰──────────────────────────────────────────────────────────╯
# *  f  = full path
# *  fs = selected files separated with the value of 'filesep', full path
# *  fx = selected files
# * lf_{option}
# * lf_user_{option}
# * lf_width
# * lf_height

# *  :  read (default)  builtin/custom command
# *  $  shell           shell command
# *  %  shell-pipe      shell command running with the ui
# *  !  shell-wait      shell command waiting for key press
# *  &  shell-async     shell command running asynchronously


# ╭──────────────────────────────────────────────────────────╮
# │                         Builtins                         │
# ╰──────────────────────────────────────────────────────────╯

cmd recol ${{
  if [[ $COLUMNS -le 90 ]]; then
    lf -remote "send $id set ratios 1:2"
  elif [[ $COLUMNS -le 160 ]]; then
    lf -remote "send $id set ratios 1:2:3"
  else
    lf -remote "send $id set ratios 1:2:3:5"
  fi
}}
# recol
# map 0
# map 0 recol

cmd on-cd &{{
  emulate -L zsh
  zmodload -F zsh/parameter p:dirstack
  autoload -Uz chpwd_recent_dirs add-zsh-hook

  source /usr/share/git/completion/git-prompt.sh
  GIT_PS1_SHOWDIRTYSTATE=auto
  GIT_PS1_SHOWSTASHSTATE=auto
  GIT_PS1_SHOWUNTRACKEDFILES=auto
  GIT_PS1_SHOWUPSTREAM=auto
  GIT_PS1_COMPRESSSPARSESTATE=auto
  git=$(__git_ps1 " [GIT BRANCH:> %s]") || true
  fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m$git\033[0m"

  # case "$PWD" in
  #   (/mnt/movies*)
  #     lf -remote "send $id set user_prev_sortby $lf_sortby"
  #     lf -remote "send $id set sortby natural"
  #     lf -remote "send $id set noreverse"
  #
  #     lf -remote "send $id echomsg changed sort to natural"
  #     ;;
  #   (*)
  #     # restore sorting on directory exit
  #     if [[ "$lf_user_prev_sortby" != "" ]]; then
  #       lf -remote "send $id set sortby $lf_user_prev_sortby"
  #       lf -remote "send $id set reverse"
  #
  #       lf -remote "send $id echomsg restored sort to $lf_user_prev_sortby"
  #       lf -remote "send $id set user_prev_sortby ''"
  #     fi
  #     ;;
  # esac

  # Add to zoxide
  [[ -d "${fx:h}" ]] && zoxide add "${fx:h}"

  # typeset -gx LF_LAUNCH_MARK
  #
  # Save a mark of the opening directory
  # if (( ! LF_LAUNCH_MARK )) {
  #   lf -remote "send $id mark-save 'a'"
  #   LF_LAUNCH_MARK=1
  #   export LF_LAUNCH_MARK
  # }

  # add-zsh-hook chpwd chpwd_recent_dirs
  # zstyle ':chpwd:*' recent-dirs-file "${ZDOTDIR}/chpwd-recent-dirs"

  # add-zsh-hook chpwd @chwpd_dir-history-var
  # add-zsh-hook zshaddhistory @append_dir-history-var
  # @chwpd_dir-history-var now
  # dir_history=("${x%%$'\n'}" "${(u)dir_history[@]}" )

  lf -remote "send $id set promptfmt \"$fmt\""
}}
on-cd

# ╭──────────────────────────────────────────────────────────╮
# │                     Helper Functions                     │
# ╰──────────────────────────────────────────────────────────╯

cmd echom ${{
  local textl equals f2 f3 res B
  f2=$'\e[38;5;52m' f3=$'\e[38;5;53m'
  res=$'\e[0m'      B=$'\e[1m'
  textl=${(c)#*}
  equals=${(l:(COLUMNS - textl - 2) / 2::=:):-}
  lf -remote "send $id echomsg \"${f2}${equals}${res} ${B}${f3}${*}${res} ${f2}${equals}${res}\""
}}

# -- Print lf id
cmd get-id %{{
  lf -remote "send $id echomsg \"lf-id: $id\""
}}

# -- Rename/change the pane title
cmd rename-title ${{
  printf "\033]2;%s\033\\" "$@"
}}


# ╭──────────────────────────────────────────────────────────╮
# │                           Tmux                           │
# ╰──────────────────────────────────────────────────────────╯

# === Tmux: quit with :q =======================================
cmd q ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --quit"
  lf -remote "send $id quit"
}}

# === Tmux: quit all with :q! ==================================
cmd q! ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --quit-all"
  lf -remote "send $id quit"
}}

# === Tmux: toggle a second lf file manager pane ===============
cmd split ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --split"
}}

# === Tmux: swap first and second lf file manager pane =========
cmd swap ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --swap"
}}

# === Tmux: open a new lf file manager (in new tab) ============
cmd new-tab ${{
 emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --new-tab"
}}

# === Tmux: open a split screen terminal =======================
cmd terminal ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --terminal"
}}

# === Tmux: open neovim in a split window ======================
cmd nvim-tmux ${{
  nvim-tmux "$fx"
}}

cmd Q :q
cmd Q! :q!
map <esc> quit
map ZZ quit

map @ :terminal

map Et :nvim-tmux
map Ev $vim "$fx"

# ╭──────────────────────────────────────────────────────────╮
# │                   Commands / Functions                   │
# ╰──────────────────────────────────────────────────────────╯
# === Open: any file ===========================================
cmd open ${{
  emulate -L zsh
  case $(file --mime-type -b -L $f) in
    (application/pdf|application/vnd*(!sqlite3)|application/epub*)
      setsid -f zathura $fx >/dev/null 2>&1 ;;
    (application/csv) vd $fx ;;
    (application/msword\
      |application/vnd.openxmlformats-officedocument.*\
      |application/vnd.oasis.opendocument.text\
      |application/vnd.ms-excel\
      |text/rtf) handlr open $fx ;;
    (application/vnd.sqlite3) litecli $fx ;;
    (text/*|application/pgp-encrypted) $EDITOR $fx ;;
    (image/x-xcf) setsid -f gimp $f >/dev/null 2>&1 ;;
    (image/svg+xml) display -- $f ;;
    (image/*) rotdir $f \
      | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|tif\|ico\)\(_large\)*$" \
      | setsid -f sxiv -aio 2>/dev/null | lf-select ;;
    (audio/*) mpv --vo=null --video=no --no-video --term-osd-bar --no-resume-playback  $f >/dev/null ;;
    (video/*) setsid -f mpv $f -quiet >/dev/null 2>&1 ;;
    (application/x-bittorrent) handlr open $fx ;;
    (application/zlib) handlr open $fx ;;
    (*)
      case ${f:e} in
        (dmg) (( $+commands[hdiutil] )) && hdiutil attach "$fx" ;;
        (bz|bz2|tbz|tbz2|gz|tgz|xz|txz|zip|rar|iso)
          mntdir="${f}-archivemount"
          [[ ! -d "$mntdir" ]] && {
            mkdir "$mntdir"
            archivemount "$f" "$mntdir"
            echo "$mntdir" >> "/tmp/__lf_archivemount_$id"
          }
          lf -remote "send $id cd \"$mntdir\""
          lf -remote "send $id reload"
        ;;
        (*)
          handlr open $fx
        ;;
      esac
      ;;
  esac

  # mpv --audio-display=no
  # *) for f in $fx; do setsid -f $OPENER $f >/dev/null 2>/dev/null & done;;
}}

cmd open-with %"$@" $fx

# === Trash: (rip) =============================================
cmd trash ${{
  setopt extendedglob
  local MATCH
  local -a arr short
  # Turn into an array
  arr=( "${(f)fx}" )
  # Since brackets are only able to be used once in lf, get tail here
  short=( ${arr:t2} )
  rip -- $fx
  dunstify -a lf " Deleted File(s)" "${(F)short}" && {
     print -Prl ${arr//(#m)*/%F{3}%B*%b %F{14}%U$MATCH%u%f: [%F{1}%Bdeleted%f%b]} \
       | hck -d ':' -D $'\t'
  }
}}

# === Move: zoxide =============================================
cmd move-file-jump ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local dest x; clear
  dest=$(_ZO_FZF_OPTS="$LF_FZF_OPTS --prompt ' Move to> '" \
      zoxide query -i || { dunstify "No file selected"; exit })
  for x ($fx) { mv -iv $x $dest } && {
    dunstify -a lf " File(s) copied" "${fx:t} => $dest"
  }
}}

# === Move: path ===============================================
cmd move-file-manual ${{
  zmodload -Fa zsh/zle b:vared
  local x dest; clear
  vared -cp "Move to: " dest
  for x ($fx) { mv -iv $x $~dest } && {
    dunstify -a lf " File(s) moved" "${fx:t} => $dest"
  }
  # mv -iv -- $fx "${~dest}"
}}


# === Copy: zoxide =============================================
cmd copy-file-jump ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local x dest; clear
  dest=$(_ZO_FZF_OPTS="$LF_FZF_OPTS --prompt ' Copy to> '" \
      zoxide query -i || { dunstify "No file selected"; exit })
  for x ($fx) { cp -pivr $x $dest } && {
    dunstify -a lf " File(s) copied" "${fx:t} => $dest"
  }
  # cp -pivr -- $fx "$dest"
}}

# === Copy: path ===============================================
cmd copy-file-manual ${{
  zmodload -Fa zsh/zle b:vared
  local x dest; clear
  vared -cp "Copy to: " dest
  for x ($fx) { cp -pivr $x $~dest } && {
    dunstify -a lf " File(s) copied." "${fx:t} => $dest"
  }
}}


# === Jump: zoxide =============================================
cmd fzf_zoxide ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local sel; clear
  sel="$(_ZO_FZF_OPTS="$LF_FZF_OPTS" zoxide query -i || { dunstify "No directory selected"; exit })"
  [[ -d "$sel" ]] && lf -remote "send $id cd \"$sel\""
}}


# === Unmount: unmount archivemount ============================
cmd unmount ${{
  fusermount -u "$f" && dunstify -a lf " Unmounted" "${f:t3}"
  rmdir "$f"
  lf -remote "send $id reload"
}}

# === Archive: unarchive =======================================
cmd unarchive ${{
  xcompress x "$f"
}}

# === Archive: archive =========================================
cmd archive ${{
  zmodload -Fa zsh/zle b:vared
  local archive; clear
  vared -cp "Archive out: " archive
  # quotes around "$fx" don't work here
  xcompress a -o "$archive" -- $fx
}}

# === Symlinks: hard and soft ==================================
# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
  zmodload -Fa zsh/files b:zf_rm
  local mode
  set ${(@f)"$(<$XDG_DATA_HOME/lf/files)"}
  mode="$1"
  shift
  if (( $# < 1 )); then
    lf -remote "send $id echo no files to link"
    exit 0
  fi
  case "$mode" in
    (copy)
      command ln -sr -t . "$@"
      dunstify -a lf "Created symlink" "${@:t3} => $PWD"
    ;;
    (move)
      command ln -t . "$@"
      dunstify -a lf "Created hardlink" "${@:t3} => $PWD"
    ;;
  esac
  zf_rm "${XDG_DATA_HOME}/lf/files"
  lf -remote "send clear"
}}


# === Symlinks: harden =========================================
# Turn a symlink into a real file
cmd harden ${{
  harden "$fx"
}}


# === Preview: video thumbnails ================================
cmd video_preview ${{
  local cache
  cache="$(mktemp "${TMPDIR:-/tmp}/thumb_cache.XXXXX")"
  ffmpegthumbnailer -i "$f" -o "$cache" -s 0
  ~/.config/lf/scripts/draw_img "$cache"
}}

# === Permissions: change ======================================
cmd chmod ${{
  zmodload -Fa zsh/zle b:vared
  local perm; clear
  vared -cp "Change permissions: " perm
  chmod -- $perm $fx
  lf -remote 'send reload'
  lf -remote 'send clear'
}}

# === Ownership: change ========================================
cmd chown ${{
  zmodload -Fa zsh/zle b:vared
  local owner; clear
  vared -cp "Ownership: " owner
  chown -- $owner $fx
  lf -remote 'send reload'
  lf -remote 'send clear'
}}

# == GPG == [[[
# === GPG: encrypt recipient ===================================
cmd gpg_encrypt_recipient %{{
  zmodload -Fa zsh/zle b:vared
  local recipient; clear
  vared -cp "Recipient: " recipient
  case "$recipient" in
    ("") printf "Cancelled.";;
    (*) gpg --encrypt --sign --recipient "$recipient" $f;;
  esac
}}

# === GPG: encrypt symmetric ===================================
cmd gpg_encrypt_pass ${{
  gpg --symmetric "$f"
}}

# === GPG: decrypt =============================================
cmd gpg_decrypt ${{
  gpg --output ${f%.gpg} --decrypt "$f"
}}

# === GPG: sign ================================================
cmd gpg_sign ${{
  gpg --sign "$f"
}}

# === GPG: sign detach =========================================
cmd gpg_sign_detach ${{
  gpg --sign --detach-sign "$f"
}}

# === GPG: clearsign file ======================================
cmd gpg_sign_clear ${{
  gpg --clearsign $f
}}

map te gpg_encrypt_recipient
map tp gpg_encrypt_pass
map td gpg_decrypt
map ts. gpg_sign
map tsd gpg_sign_detach
map tsc gpg_sign_clear

map tT $gpg-tui # gpg-tui
# ]]]

# === Config: lfrc =============================================
cmd edit_config :{{
  $$EDITOR ~/.config/lf/lfrc
  source ~/.config/lf/lfrc
}}


# === Config: lf scope =========================================
cmd edit_scope :{{
  $$EDITOR ~/.config/lf/scope
  source ~/.config/lf/scope
}}


# === Diff: between two files ==================================
cmd diff_files !{{
  local -a files; files=( ${(@f)fx} )
  (( $#files == 2 )) && {
    clear; delta $files[1] $files[2]
  }
}}

# === Diff: nvim ===============================================
cmd nvim_diff ${{
  local -a files; files=( ${(@f)fx} )
  (( $#files == 2 )) && {
    clear; nvim -d +0 $files
  }
}}

map D diff_files
map df nvim_diff

cmd node_script ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local script; clear
  script=$(cat package.json | jq -r '.scripts | keys[] ' | sort \
      | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fzf))
  [[ -n "$script" ]] && npm run $(print -r -- "$script")
}}

# TODO: FINISH
# -- Checksum: get the checksum of a file or directory
cmd chksum ${{
  zmodload -Fa zsh/zle b:vared
  local chksum_resp chksum

  chksum="blake3"

  clear
  print -nPr "%F{21}"
  print -f "%s" "$(figlet checksum)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Possibilities: MD5, SHA1, SHA224, SHA256, SHA384, SHA512, BLAKE3 Create MD5 (m), SHA256 (s), SHA512 (S), BLAKE3 (b) (or type one of the above) [default=b]: " chksum_resp

  if [[ $chsum_resp = "s" ]]; then
    chsum=sha256
  elif [[ $chsum_resp = "S" ]]; then
    chsum=sha512
  fi

  case "$chksum" in
    (m) chksum="md5"    ;;
    (s) chksum="sha256" ;;
    (S) chksum="sha512" ;;
    (*) chksum="blake3" ;;
  esac
}}

map C chksum

# === Select: all files ========================================
cmd select-files ${{
  local -a files; files=( ${(@f)"$(fd . -L -d1 -tf)"} )
  for fi in "${files[@]}"; do
    lf -remote "send $id toggle $fi"
  done
}}

# === Select: all dirs =========================================
cmd select-dirs ${{
  local -a dirs; dirs=( ${(@f)"$(fd . -L -d1 -td)"} )
  for d in "${dirs[@]}"; do
    lf -remote "send $id toggle $d"
  done
}}

# === Select: all executables ==================================
cmd select-exec ${{
  local -a xx; xx=( ${(@f)"$(fd . -L -d1 -tx)"} )
  for x in "${xx[@]}"; do
    lf -remote "send $id toggle $x"
  done
}}

# === Tag Jump: builtin lf tags ================================
cmd jump_tag ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local tags="${XDG_DATA_HOME}/lf/tags"; clear
  [[ ! -r $tags ]] && {
    dunstify "No tag file found"
    return
  }

  local target=$(\
    column -t -s':' $tags | sort -k 2,2 \
      | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Jump> '" fzf \
        || { dunstify "No tag selected"; exit }) \
      | hck -f1
  )

  if [[ -d "$target" ]]; then
    lf -remote "send $id cd '$target'"
  elif [[ -n "$target" ]]; then
    lf -remote "send $id cd '${target:h}'"
  fi
}}

# === Bookmark Jump: specifically for lf =======================
cmd njump ${{
  bookmarks="${XDG_DATA_HOME}/lf/bookmarks"
  jump_file=$(mktemp -u --tmpdir "lf-jump.XXXXX")
  trap 'rm "$jump_file"' INT QUIT TERM EXIT
  fd -Hi -d1 -td -c never > "$jump_file"
  [[ -r "$bookmarks" ]] && cat "$bookmarks" >> "$jump_file"

  target=$(fzf --no-info --pointer=cd \
    --header="Jump to location" < <(sort -Vu "$jump_file"))
  lf -remote "send $id cd '$target'"
}}

# === Bookmark: specifically for lf ============================
cmd nbookmark ${{
  bookmarks_file="${XDG_DATA_HOME}/lf/bookmarks"
  bookmark_path="${f%/*}"
  mkdir -p "$(dirname -- "$bookmarks_file)")"
  echo "${bookmark_path}" >> "$bookmarks_file"
  sort -u "$bookmarks_file" > "$bookmarks_file.$$"
  mv -f "$bookmarks_file.$$" "$bookmarks_file"
  lf -remote "send $id echomsg Bookmark to '$bookmark_path' created."
}}

# === Bookmark: delete =========================================
cmd ndel-bookmark ${{
  bookmarks_file="${XDG_DATA_HOME}/lf/bookmarks"
  pth=$(cat "${bookmarks_file:?}" | fzf --no-sort)
  sd "$pth\n" "" "${bookmarks_file:?}"
  lf -remote "send $id echomsg Bookmark $pth deleted."
}}


# === Jump: ====================================================
cmd jumpInteractive ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  zmodload -Fa zsh/parameter p:commands
  clear
  local field esc N R G Y B pattern res
  local -a bmark_dirs
  field='\(\S\+\s*\)'
  esc=$'\e'
  N="${esc}[0m"
  R="${esc}[31m"
  G="${esc}[32m"
  Y="${esc}[33m"
  B="${esc}[34m"
  pattern="s#^${field}${field}${field}${field}#$Y\1$R\2$N\3$B\4$N#"

  [[ -v commands[dasel] && -f $XDG_DATA_HOME/rualdi/rualdi.toml ]] && {
    res=$(\
      dasel -f $XDG_DATA_HOME/rualdi/rualdi.toml -s '.aliases' \
        | perl -pe 's{ = }{ → }; s/"//g' | nl | column -t \
        | sed "${pattern}" \
        | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS" \
            fzf --ansi \
                --preview='\
                f={}; bkt -- exa -T --color=always -L3 -- $(sed "s#.*→  ##" <<<"$f")' \
              --preview-window="right:50%" \
            || { dunstify 'No bookmark selected'; exit }) \
        | sed 's#.*→  ##')
    [[ -d "$res" ]] && lf -remote "send $id cd \"$res\""
  }
}}

# === CD: using FZF (depth=1) ==================================
cmd fzf_cd ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local ret; clear
  ret="$(fd . -d1 -td -HiL \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Cd> '" fzf \
        || { dunstify "No directory selected"; exit }))"
  lf -remote "send $id cd '$ret'"
}}

# === CD: using FZF (depth=~) ==================================
cmd fzf_cd_depth ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local ret; clear
  ret="$(fd . -d4 -td -HiL \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Cd> '" fzf \
        || { dunstify "No directory selected"; exit }))"
  lf -remote "send $id cd '$ret'"
}}

# === CD: follow symlink =======================================
cmd cd-realpath ${{
  # origin=${${:-"$f"}:A}
  local origin
  # origin="$(realpath -- "$(readlink -f -- "$fx")")"
  origin="$(realpath -- "$fx")"
  lf -remote "send $id select '$origin'"
}}

# === Copy: follow symlink =====================================

# === TAGS === [[[
# === Tag: tmsu set ============================================
cmd tmsu-set ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet tmsu)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Set tag: " tmsu_tag
  tmsu tag --tags="$tmsu_tag" $fx
}}

# === Tag: tmsu list specific file =============================
cmd tmsu-remove ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet tmsu)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Remove tag: " tmsu_tag
  tmsu untag --tags="$tmsu_tag" $fx
}}

# === Tag: tmsu remove =========================================
cmd tmsu-list !{{
  clear
  tmsu tags "$fx" | bat -l bash --paging=always
}}

# === Tag: wutag set ===========================================
cmd wutag-set ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet wutag)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Set tag: " tag
  for x in $fx; do
    fname="${x:t}"; fdir="${x:h}"
    wutag -d "${fdir}/" set -c $fname $tag
  done
}}

# === Tag: wutag add ===========================================
cmd wutag-add ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet wutag)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Add tag: " tag
  for x in $fx; do
    fname="${x:t}"; fdir="${x:h}"
    wutag -d "${fdir}/" set $fname $tag
  done
}}

# === Tag: wutag remove ========================================
cmd wutag-remove ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet wutag)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Remove tag: " tag
  for x in $fx; do
    fname="${x:t}"; fdir="${x:h}"
    wutag -d "${fdir}/" rm $fname
  done
}}

# === Tag: wutag list ==========================================
cmd wutag-list !{{
  clear
  noglob wutag --color=always list files -tf | bat -f
}}
# ]]] === TAGS ===

# ╭─────────╮
# │ Finding │
# ╰─────────╯

cmd fzf $clear; nvim $(fd -Hi -tf "$1" . |  fzf --no-height) # Find file with pattern
cmd fd !clear; fd -Hi "$@"     # Find file at any depth
cmd fD !clear; fd -Hi -d1 "$@" # Find file current depth
cmd rg !clear; rg "$1"         # Normal grep
# Grep with FZF
cmd rgu ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  clear;
  FZF_DEFAULT_OPTS="$LF_FZF_OPTS" rgu "$1"
}}

# === FZF: edit file ===========================================
cmd fd_edit ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local -a files; clear
  files=( ${(@f):-"$(command fd -Hi -tf .)"} )
  print -rl -- "$files[@]" | lscolors \
    | FZF_DEFAULT_OPTS="$LF_FZF_OPTS" \
    fzf --multi \
      --select-1 \
      --exit-0 \
      --bind='ctrl-e:become($EDITOR {})' \
      --bind='enter:become($EDITOR {})' \
      --preview-window=':nohidden,right:65%:wrap' \
      --preview='([[ -f {} ]] && (bat --style=numbers --color=always {})) || ([[ -d {} ]] && (exa -TL 3 --color=always --icons {} | less)) || echo {} 2> /dev/null | head -200'
}}

# ╭──────────────────────────────────────────────────────────╮
# │                      Miscellaneous                       │
# ╰──────────────────────────────────────────────────────────╯

# rsync [[[
cmd rsyncto ${{ rsync -uvrP $fx root@lmburns.com:"$1" }}
cmd rsyncfrom ${{ rsync -uvrP root@lmburns.com:"$1" "$2" }}

cmd rsync_to_mac ${{ rsync -uvrP "$fx" macbook:/Users/lucasburns/"$1" }}
cmd rsync_from_mac ${{ rsync -uvrP macbook:/Users/lucasburns/"$1" "$2" }}
# ]]]

# Rename
cmd massren $massren $fx
cmd mmv $mmv -- ${${(@f)fx}:t}
cmd f2 !f2 -f "$1"
cmd rmspace $f2 -f '\s' -r '_' -RFx

cmd wim $wim "$1"

# Yanking
cmd yank-path ${{
  print -r "$fx" \
    | xclip -r -selection c && dunstify -a lf "File Path" "$fx\nCopied to clipboard"
}}
cmd yank-name ${{
  print -r "${fx:t}" \
    | xclip -r -selection c && dunstify -a lf "File Name" "${fx:t}\nCopied to clipboard"
}}
cmd yank-dir ${{
  print -r "${fx:h}" \
    | xclip -r -selection c && dunstify -a lf "Directory" "${fx:h}\nCopied to clipboard"
}}
cmd yank-realpath ${{
  local origin
  origin="$(realpath -- "$fx")"
  print -r "$origin" \
    | xclip -r -selection c && dunstify -a lf "Absolute File Path" "$origin\nCopied to clipboard"
}}

cmd disk-info !clear; dust; diskus

# Basic operations
cmd take %mkdir -p "${@}" && lf -remote "send $id cd \"$@\""
cmd mkdir %[[ -n "${1}" ]] && mkdir -p "${@}" || echo "Argument needed"
cmd mkfile %[[ -n "${1}" ]] && touch "${@}" || echo "Argument needed"

# Create dir and move selected files into it
cmd newfold ${{
  zmodload -Fa zsh/zle b:vared
  clear; vared -cp "Folder: " fold
  mkdir -p -- "$fold" && mv -- $fx "$fold"
}}

# Dragon [[[
cmd dragon %dragon -a -x $fx
cmd dragon-stay %dragon -a $fx
cmd dragon-individual %dragon $fx
cmd cpdragon %cpdragon
cmd mvdragon %mvdragon
cmd dlfile %dlfile
# ]]]

# ========================== ZLE ========================== [[[
# === ZLE: change directories ===================================
cmd zle-cd %{{
  print -l -- "_p9k_precmd; builtin cd "$PWD"; zle reset-prompt; zle -R" >&$ZLE_FIFO
}}

# === ZLE: insert path into CLI =================================
cmd zle-insert-relative %{{
  for f ($fx) {
    print -l -- "LBUFFER+=${LBUFFER:+ }${(q)$(realpath "$f" --relative-to=$PWD)}" >&$ZLE_FIFO
  }
}}

# === ZLE: insert abspath into CLI =============================
cmd zle-insert-absolute %{{
  for f ($fx) {
    print -l -- "LBUFFER+=${LBUFFER:+ }${f}" >&$ZLE_FIFO
  }
}}

# === ZLE: initialize ==========================================
cmd zle-init :{{
  map , zle-cd
  map ap zle-insert-relative
  map aP zle-insert-absolute
}}

&[[ -n "$ZLE_FIFO" ]] && lf -remote "send $id zle-init"
# ]]] === ZLE ===

# ╭──────────────────────────────────────────────────────────╮
# │                         Mappings                         │
# ╰──────────────────────────────────────────────────────────╯

# Unmappings [[[
# map n
# map "'"
# map '"'
map m
map M
map d
map O
map e
map w
map i
map c
map f
map gh
map .
map r
map t
map <c-l>
map H
map L
map v
map ]
map [
# ]]]

# == File Openers == [[[
map ee $$EDITOR "$f"                            # open file in editor
map ec edit_config                              # edit & source lfrc
map es edit_scope                               # edit lfrc scope
map ev $$EDITOR $NVIMRC                          # open nvim config
map ew $$EDITOR $HOME/vimwiki/index.md          # open vimwiki
map ez $$EDITOR $ZDOTDIR/.zshrc                 # edit zshrc
map ea $$EDITOR $ZDOTDIR/zsh.d/aliases.zsh      # edit zsh aliases
map eb $$EDITOR $ZDOTDIR/zsh.d/keybindings.zsh  # edit zsh bindings
map ei $$EDITOR $ZDOTDIR/zsh.d/lficons.zsh      # edit lf colors/icons
map et $$EDITOR $XDG_CONFIG_HOME/tmux/tmux.conf # edit tmux conf

map v ${{
  # bat view file
  clear; LESS='-iWQMXR~' bat --paging=always --theme=kimbro "$f"
}}
map ? ${{
  # open lfrc docs
  clear; batman lf
}}
map gH ${{
  # open lf mappings
  clear; bat -l bash -f ~/.config/lf/mappings
}}
map Ow push :open-with<space>                       # open w/ specified program
map Op &{{
  # open curr directory in pcmanfm
  pcmanfm $PWD
}}
map o  ${{
  # handlr open ask
  clear; handlr ask --config $f
}}
map Oa ${{
  # mimeopen ask
  mimeopen --ask $f
}}
# map Oa $mimeopen $f

map Qm !{{
  # preview in mdcat
  clear; mdcat -p $fx
}}
map Qg !{{
  # preview in glow
  clear; glow -p $fx
}}
# map Sa $$XDG_CONFIG_HOME/lf/sxiv-preview "$f" # attempt to preview all imgs

map ad disk-info                # get disk information
map as !{{
  # directory info
  clear; du -hsx * | sort -rh | bat --paging=always
}}
map ai !{{
  # file information
  clear; file-info $f
}}
map aI ${{
  # dua interactive
  dua i
}}

map <c-f> push :rg<space> # search with rg
map F push :rgu<space>    # search interactively with fzf

map Tk !{{
  # tokei
  clear; tokei
}}
# ]]]

# == Archive Mappings == [[[
map aU unarchive
map aA archive
map au unmount
# ]]]

# == Trash Mappings == [[[
map dd trash                  # rip
map du %{{
  # undo last delete
  rip -u
}}
map de %{{
  # empty trash
  rip -d
}}
map dl ${{
  # list trash with fzf
  clear; rip -as | FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fzf
}}
map dm ${{
  # trash delete with fzf
  FZF_DEFAULT_OPTS="$LF_FZF_OPTS" frip
}}
map dr ${{
  # fzf trash restore script
  FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fripu
}}

# map Dp $dump -p -s       # dump - interactive delete
# map Dr $dump -u -s       # dump - restore interactive
# ]]]

# == Dragon Mapping == [[[
map drr dragon
map drs dragon-stay
map dri dragon-individual
map drm mvdragon
map drc cpdragon
map drl dlfile
# ]]]

# == Renaming == [[[
map A rename                # at the very end
map cn push A<c-u>          # new rename
map I push A<c-a>           # at the beginning
map i push A<a-b><a-b><a-f> # before extention
map aa push A<a-b>          # after extention
map ch chmod                # change file permissions
map =  chmod                # change file permissions
map cH chown                # change file owner

map Bf push :f2<space>      # use f2 to rename
map Bm massren              # bulk rename with massren
map Bv mmv                  # bulk rename only with selected
map Bs rmspace              # remove spaces from filenames
# ]]]

# == File selection / Directory Movement == [[[
map fo push :fzf<space>   # fzf search and open
map fd push :fd<space>    # use fd to find file
map fr push :fd<space>-d1<space>--changed-within<space> # use fd to find recent file
map fe fd_edit            # find files with fzf and edit (with preview)

map cc fzf_zoxide         # fzf zioxide
map ci jumpInteractive    # rualdi fzf
map cJ njump              # lf specifc - jump bookmark
map cB nbookmark          # lf specifc - add bookmark
map cD ndel-bookmark      # lf specifc - del bookmark

map w fzf_cd              # fzf cd
map W fzf_cd_depth        # fzf cd further depth
map Ma $neomutt -a "$fx"  # mail a file

map U unselect
map , :{{ clear; unselect; }}
map V invert

map sf select-files
map sd select-dirs
map sx select-exec
map sF ${{
  # select files fzf
  setopt localtraps err_exit; trap "return 0" EXIT
  for f ($(\
      print -ln -- *(ND) \
        | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS -m" fzf || { dunstify "No files selected"; exit })
  )) {
    lf -remote "send $id toggle $f"
  }
}}
map ss set globsearch!            # change search type
map sg push :glob-select<space>   # select files matching pattern
map sG push :glob-unselect<space> # unselect files matching pattern

map ff push :filter<space>
map rl find
map rh find-back
map <gt> find-next
map <lt> find-prev
# ]]]

# == General == [[[
map - ${{
  # turn a symlink into a real file
  harden "$fx"
}}

# TODO: Finish
# paste a file and make sure its not a symlink
map Ph ${{
  zmodload -Fa zsh/files b:zf_rm
  local ofile nfile
  lf -remove load
  lf -remote "send $id paste"
  # ofile=${${(@f)"$(<$XDG_DATA_HOME/lf/files)"}[2]}
  # nfile="${PWD}/${ofile:t}"
  # lf -remote "send $id select '$nfile'"
  # harden "$nfile"

  # zf_rm "${XDG_DATA_HOME}/lf/files"
  # lf -remote "send clear"
}}

# TODO: Finish
cmd copy-realpath ${{
  local origin
  origin="$(realpath -- "$fx")"
  lf -remote "send $id copy '$origin'"
}}


map x cut                     # general cut
map p paste                   # regular
map Pl :{{ link; unselect; }} # paste a symlink

# map y
map y copy           # general copy
map Yr copy-realpath # general copy absolute path

map YR yank-realpath # yank absolute path
map Yp yank-path     # yank file path
map Yn yank-name     # yank name of file path
map Yd yank-dir      # yank name of directory
map Yu ${{
  # yank URL of git repo
  ngu
}}
map Ya ${{
  # yank author of git repo
  nga
}}
map Yj copy-file-jump                             # copy to directory with zoxide
map Ym copy-file-manual                           # copy to directory with path entered

map Mj move-file-jump   # move to directory with zoxide
map Mp move-file-manual # move to directory with path

map Mt push :rsyncto<space>        # move things to the server
map Mf push :rsyncfrom<space>      # move things from the server
map Ml push :rsync_to_mac<space>   # move things to the macbook
map Mm push :rsync_from_mac<space> # move things from the macbook

map ms $mksc               # create script
map mf push :mkfile<space> # create file
map md push :mkdir<space>  # create dir
map mt push :take<space>   # create dir and cd into it
map mD newfold             # create dir and move selected files into it

# Move to the top
map gg top -- []
map G bottom -- [] # Move to the bottom
map J half-down    # Move halfway down
map K half-up      # Move halfway up

map R reload
map <c-n> &{{
  lf -remote "send $id redraw"
  lf -remote "send $id echom 'Redrawn'"
}}

map <c-l> cd-realpath
map } cd-realpath
map H jump-prev
map L jump-next

map . set hidden!

map s1 :{{ set preview;   set ratios 1:2:3; }}   # set display (preview)
map s2 :{{ set preview;   set ratios 1:2; }}     # set display (no preview)
map s3 :{{ set nopreview; set ratios 1:3; }}     # set display (preview)

map sR :{{ set reverse!; }}                      # reverse file order

map sn :{{ set sortby natural; set info size; set noreverse; }} # revert back to normal sort
map sa :{{ set sortby atime; set info atime; set reverse; }}
map sc :{{ set sortby ctime; set info ctime; set reverse; }}
map st :{{ set sortby time; set info time; set reverse; }}
map se :{{ set sortby ext; set info; set noreverse; }}

map S :{{
  # revert sort back to normal
  set sortby natural; set info size;     set noreverse ;
  set preview;        set ratios 1:2:3;
}}
# ]]]

# == Shell == [[[
# map <c-s> shell                       # enter shell command
map <c-x>s shell-wait                  # enter shell cmd
map <c-x>x $$f                          # execute file
map <c-x>X !$f                          # execute file and $PAGER output
map <c-x>l $$f | bat --paging=always -f # execute file and bat output
map <c-x>w push :wim<space>             # open script source code
map <c-x>p $cat $fx | up                # cat file to up (unix piper)
# ]]]

# == Torrent == [[[
map toa $transmission-remote --add $fx # add torrent
map toT $tide                          # transmisison TUI
map tos $stig                          # transmisison TUI
# ]]]

# == Tagging == [[[
# map <c-_> mark-save
# map ma mark-save
map <a-.> mark-save
map <a-'> mark-save
map "'" mark-load
map '"' mark-remove

# map ; push :tag<space>
map <a-,> push :tag<space>
map X tag-toggle
map Tj jump_tag

map Tms tmsu-set
map Tmr tmsu-remove
map Tml tmsu-list

map Ts wutag-set
map Ta wutag-add
map Tr wutag-remove
map Tl wutag-list
# ]]]

# == Git == [[[
cmd dotbare_add ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  for x ($fx) { FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare add "$x" }
}}
cmd git_add $for x ($fx) { git add "$x" }
cmd git_branch ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local pwd_shell; clear
  git branch \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fzf) \
    | xargs git checkout
  pwd_shell=$(pwd)
  lf -remote "send $id updir"
  lf -remote "send $id cd \"$pwd_shell\""
}}

cmd git_reclone_repo ${{
  ngu | xsel -ib
  rip -- *
  gh c $(xsel -b)
  t=$PWD:t
  command rsync -vua --delete-after ${t:?invalid current dir}/ .
}}

cmd mgit_pull_rebase !{{
  emulate -L zsh -o extendedglob
  zmodload -Fa zsh/zle b:vared
  local ans; clear
  vared -cp 'Confirm rebase [Y/n]: ' ans
  [[ $ans == (#i)y(es|) ]] && mgit pull --rebase
}}

map gta :{{ git_add; unselect; }}
map gtr :git_reclone_repo
map gtb :git_branch
map gtc ${{
  # git clone repo from clipboard
  clear; gclp
}}
map gtp !{{
  # git pull
  clear; git pull
}}
map gtP !{{
  # git pull --rebase
  clear; git pull --rebase
}}
map gtz !{{
  # git status
  clear; git status
}}
map gtl !{{
  # git log oneline
  clear; git la
}}
map gtL !{{
  # git log oneline stat
  clear; git lo
}}
map gl  ${{
  # git log full diff
  clear; git log -p
}}
map gts !{{
  # git log full diff+signature
  clear; git show --show-signature
}}
map go  &{{
  # open git repo URL
  git brws
}}

map gm :mgit_pull_rebase

# map gttr ${{clear; git ls-tree -r master --name-only | bat}}
# map gttt ${{clear; git ls-tree -r master --name-only | as-tree --color always | bat -p}}
# map gttu ${{clear; git ls-files --other | bat}}

# map gFd ${{clear; f::diff}}
# map gFc ${{clear; f::clean}}
map gfs ${{
  # fstat
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fstat
}}
map gfa ${{
  # fadd
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fadd
}}
map gfl ${{
  # flog
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" flog
}}
map gfu ${{
  # funtrack
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" funtrack
}}

map gda :{{ dotbare_add; unselect; }}
map gdai ${{
  # dotbare fadd
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare fadd -f
}}
map gds ${{
  # dotbare fstat
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare fstat
}}
map gdu ${{
  # dotbare funtrack
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare funtrack
}}

# map gftr ${{clear; dotbare ls-tree -r master --name-only | bat}}
# map gftt ${{clear; dotbare ls-tree -r master --name-only | as-tree --color always | bat -p}}
# map gftu ${{clear; dotbare ls-files --other | bat}}
# ]]]

# == TUI's == [[[
map gTt $tig show # tig
map gTu $gitui    # git
map gL $lazygit   # git
map bo $bow       # buku bookmarks
# ]]]

# Doesn't work in tmux?

# map <m-1> down
# map <m-2> down
# map <c-m-up> up
# map <c-m-down> down

# ╭──────────────────────────────────────────────────────────╮
# │                     Change Directory                     │
# ╰──────────────────────────────────────────────────────────╯
map bc cd ~/.config
map bi cd /run/media/lucas
map bh cd ~

# vim: ft=lf:et:sw=2:ts=2:sts=-1:fdm=marker:fmr=[[[,]]]:
