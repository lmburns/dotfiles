# ╭──────────────────────────────────────────────────────────╮
# │                     Basics / General                     │
# ╰──────────────────────────────────────────────────────────╯ [[[

# TODO: toggle anchorfind for find command only
# TODO: add diffsitter
# TODO: Add dirstack like thing to lf
# TODO: add clone dir and select

#function cmc() { $EDITOR ${$(cargo locate-project | jq -r '.root'):h}/Cargo.toml; }
#function shredd() { shred -v -n 1 -z -u  $1;  }
#function pbpf() { xsel -b > "$1"; }
#function lnbin() { ln -siv $HOME/mybin/$1 $XDG_BIN_HOME; }
#function unlbin() { rm -v $XDG_BIN_HOME/$1; }
#function sha256dir() { fd . -tf -x sha256sum | cut -d' ' -f1 | sort | sha256sum | cut -d' ' -f1; }
#function b3sumdir()  { b3sum <<<${(@of):-"$(fd $1 -tf -x b3sum --no-names)"} }
#function megahash() { b3sum <<<${(pj:\0:)${(@s: :)"$(rhash --all $@)"}[2,-1]}; }
#function ng() { command git rev-parse >/dev/null 2>&1 && nvim +"lua require('plugs.fugitive').index()" }

# Comments may be found in functions like ${{}} or !{{}} to provide
# documention in the popup menu when pressing keybindings

set shell zsh
set shellopts '-euy:--rcquotes'
set ifs "\n"
set filesep "\n"  # default already

set tabstop 4        # number of spaces for a tab
set scrolloff 10     # space on top and bottom of screen
set icons            # show icons next to files
set history          # save history across sessions
set period 1         # interval to check for directory updates
set hidden           # show hidden files by default
set incsearch        # jump to first match after each keystroke in search
set incfilter        # apply filter after each keystroke
set smartcase        # if capital letter then case sensitive
set dirfirst         # show directories before regular files
set dircounts        # show number of items in directory instead of size
# set dirpreviews      # pass directories to the previewer script
set info "size"      # list directory information on the right
set sortby "natural" # don't sort files in any special way
set preview          # preview file on the right pane
set drawbox          # draw a border around all panes
set ratios '1:2:3'   # ratio of pane widths

# set number on         # show number of items index in dir
# set globsearch        # search with globs

# * '%u' username
# * '%h' hostname
# * '%w' working directory
# * '%d' working directory with trailing path separator
# * '%f' file name
# * '%F' current filter
# * '%S' provide spacer for right alignment
#  Default:   "\033[32;1m%u@%h\033[0m:\033[34;1m%d\033[0m\033[1m%f\033[0m"

# \033[32;1m%u\033[0m
# \033[1;38;2;234;105;98m@\033[0m
# \033[1;38;2;76;150;168m%h\033[0m    # Alt: # \033[1;96m%h\033[0m
# \033[1;38;5;21m:\033[0m
# \033[34;1m%d\033[0m
# \033[1;38;2;42;176;116m%d\033[0m

# set cursorfmt="\033[4m"
# set cursorpreviewfmt="\033[4m"
# set cursorfmt="%s"
# set cursorpreviewfmt="%s"

set promptfmt "\033[1;38;5;53m%u\033[0m\033[1;38;5;48m@\033[0m\033[1;38;5;19m%h\033[0m\033[1;38;5;1m:\033[0m\033[1;38;5;52m%d\033[0m\033[1;38;5;22m%f\033[0m\033[1;38;5;12m${git}\033[0m \033[1;38;5;4m[%F]\033[0m"
set tagfmt "\033[1;38;5;018m"
set errorfmt "\033[7;38;5;017m"

set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml:lost+found"
set tempmarks '1234567890'

# -- Previewer: custom
$lf -remote "send $id set previewer ${XDG_CONFIG_HOME}/lf/scope"
$lf -remote "send $id set cleaner ${XDG_CONFIG_HOME}/lf/scripts/cleaner"
# ]]]

# ╭──────────────────────────────────────────────────────────╮
# │                 Environmental Variables                  │
# ╰──────────────────────────────────────────────────────────╯ [[[
# f  = full path
# fs = selected files separated with the value of 'filesep', full path
# fx = selected files
# lf_{option}
# lf_user_{option}
# lf_width
# lf_height

# :  read (default)  builtin/custom command
# $  shell           shell command
# %  shell-pipe      shell command running with the ui
# !  shell-wait      shell command waiting for key press
# &  shell-async     shell command running asynchronously

# open      : override default 'open' command when current file is not a directory
# paste     : override default 'paste' command
# rename    : override the default 'rename' command
# delete    : override the default 'delete' command
# pre-cd    : executed before changing a directory
# on-cd     : executed after changing a directory
# on-select : executed after the selection changes
# on-quit   : executed before quit

# ╭──────────────────────────────────────────────────────────╮
# │                         Builtins                         │
# ╰──────────────────────────────────────────────────────────╯ [[[

# === Builtins: change panel width based on $COLUMNS ==========
cmd recol ${{
  if [[ $COLUMNS -le 90 ]]; then
    lf -remote "send $id set ratios 1:2"
  elif [[ $COLUMNS -le 160 ]]; then
    lf -remote "send $id set ratios 1:2:3"
  else
    lf -remote "send $id set ratios 1:2:3:5"
  fi
}}
# recol
map 0
map 0 recol

# === Builtins: function ran on every CD =======================
cmd on-cd &{{
  emulate -L zsh
  zmodload -F zsh/parameter p:dirstack
  autoload -Uz chpwd_recent_dirs add-zsh-hook

  source /usr/share/git/completion/git-prompt.sh
  GIT_PS1_SHOWDIRTYSTATE=auto
  GIT_PS1_SHOWSTASHSTATE=auto
  GIT_PS1_SHOWUNTRACKEDFILES=auto
  GIT_PS1_SHOWUPSTREAM=auto
  GIT_PS1_COMPRESSSPARSESTATE=auto
  git=$(__git_ps1 " [GIT BRANCH:> %s]") || true
  # fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m$git\033[0m"
  fmt="\033[1;38;5;53m%u\033[0m\033[1;38;5;48m@\033[0m\033[1;38;5;19m%h\033[0m\033[1;38;5;1m:\033[0m\033[1;38;5;52m%d\033[0m\033[1;38;5;22m%f\033[0m\033[1;38;5;12m${git}\033[0m \033[1;38;5;4m[%F]\033[0m"
  # fmt="\033[32;1m%u\033[0m\033[1;38;2;234;105;98m@\033[0m\033[1;38;2;76;150;168m%h\033[0m\033[1;38;5;21m:\033[0m\033[1;38;2;42;176;116m%d\033[0m\033[1m%f\033[0m %F"

  # case "$PWD" in
  #   (/mnt/movies*)
  #     lf -remote "send $id set user_prev_sortby $lf_sortby"
  #     lf -remote "send $id set sortby natural"
  #     lf -remote "send $id set noreverse"
  #
  #     lf -remote "send $id echomsg changed sort to natural"
  #     ;;
  #   (*)
  #     # restore sorting on directory exit
  #     if [[ "$lf_user_prev_sortby" != "" ]]; then
  #       lf -remote "send $id set sortby $lf_user_prev_sortby"
  #       lf -remote "send $id set reverse"
  #
  #       lf -remote "send $id echomsg restored sort to $lf_user_prev_sortby"
  #       lf -remote "send $id set user_prev_sortby ''"
  #     fi
  #     ;;
  # esac

  # Add to zoxide
  [[ -d "${fx:h}" ]] && zoxide add "${fx:h}"

  # typeset -gx LF_LAUNCH_MARK
  #
  # Save a mark of the opening directory
  # if (( ! LF_LAUNCH_MARK )) {
  #   lf -remote "send $id mark-save 'a'"
  #   LF_LAUNCH_MARK=1
  #   export LF_LAUNCH_MARK
  # }

  # add-zsh-hook chpwd chpwd_recent_dirs
  # zstyle ':chpwd:*' recent-dirs-file "${ZDOTDIR}/chpwd-recent-dirs"

  # add-zsh-hook chpwd @chwpd_dir-history-var
  # add-zsh-hook zshaddhistory @append_dir-history-var
  # @chwpd_dir-history-var now
  # dir_history=("${x%%$'\n'}" "${(u)dir_history[@]}" )

  lf -remote "send $id set promptfmt \"$fmt\""
}}
on-cd
# ]]]

# ╭──────────────────────────────────────────────────────────╮
# │                     Helper Functions                     │
# ╰──────────────────────────────────────────────────────────╯ [[[

# === Helper: echo a message ===================================
cmd echom ${{
  unsetopt shwordsplit
  local textl equals str
  textl=${(c)#*}
  equals=${(l:(COLUMNS - textl - 2) / 2::=:):-}
  str="%F{52}$equals%f %F{53}%B${*}%b%f %F{52}$equals%f"
  lf -remote "send $id echomsg \"${(%)str}\""
}}

# === Helper: display an error =================================
cmd echoe ${{
  unsetopt shwordsplit
  local str; str="%B%F{1}[ERROR]%f%b: $*"
  lf -remote "send $id echomsg \"${(%)str}\""
}}

# === Helper: display a warning ================================
cmd echow ${{
  unsetopt shwordsplit
  local str; str="%B%F{11}[WARN]%f%b: $*"
  lf -remote "send $id echomsg \"${(%)str}\""
}}

# Needs some work. This is always called after the function it's called within.
# === Helper: display a message with figlet ====================
cmd figlet ${{
  local idx; clear
  print -Pr "%F{47}%B${(l:COLUMNS::=:):-}%b%f"
  print -nPr "%F{52}%B"
  idx=1; for arg ("$@") {
    if (( idx == $# )) {
      print -rn "$(figlet -tc "$arg")"
    } else {
      print -r "$(figlet -tc "$arg")"
    }
    (( idx ++ ))
  }
  print -Pr "%b%f"
  print -Pr "%F{47}%B${(l:COLUMNS::=:):-}%b%f"
  print
}}

# === Helper: print lf $id =====================================
cmd get-id %{{
  lf -remote "send $id echomsg \"lf-id: $id\""
}}

# === Helper: dump the environment =============================
cmd dump-env ${{
  # command env
  typeset -g \
    | sed -E '/^(((Z)?L[SF]|TREE)_COLORS|LF_ICONS|(DOTBARE_)?(FZF|SKIM)_DEFAULT_|(FZF|SKIM)_(ALT|CTRL)_|MAPATH)/d' \
    | bat -l bash --paging=always --style=numbers
}}

# === Helper: rename the pane title ============================
cmd rename-title ${{
  printf "\033]2;%s\033\\" "$@"
}}
# ]]]

# ╭──────────────────────────────────────────────────────────╮
# │                           Tmux                           │
# ╰──────────────────────────────────────────────────────────╯ [[[

# === Tmux: quit with :q =======================================
cmd q ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --quit"
  lf -remote "send $id quit"
}}

# === Tmux: quit all with :q! ==================================
cmd q! ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --quit-all"
  lf -remote "send $id quit"
}}

# === Tmux: toggle a second lf file manager pane ===============
cmd split ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --split"
}}

# === Tmux: swap first and second lf file manager pane =========
cmd swap-tmux ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --swap"
}}

# === Tmux: open a new lf file manager (in new tab) ============
cmd new-tab ${{
 emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --new-tab"
}}

# === Tmux: open a split screen terminal =======================
cmd terminal ${{
  emulate zsh -R -c "${XDG_CONFIG_HOME}/lf/scripts/tmux_helper --terminal"
}}

# === Tmux: open neovim in a split window ======================
cmd nvim-tmux ${{
  nvim-tmux "$fx"
}}

cmd Q :q
cmd Q! :q!
# ]]]

# ╭──────────────────────────────────────────────────────────╮
# │                   Commands / Functions                   │
# ╰──────────────────────────────────────────────────────────╯ [[[
# === File Openers ============================================= [[[
# === Opener: any file =========================================
cmd open ${{
  emulate -L zsh
  case $(file --mime-type -b -L $f) in
    (application/pdf|application/vnd*(!sqlite3)|application/epub*)
      setsid -f zathura $fx >/dev/null 2>&1 ;;
    (application/csv) vd $fx ;;
    (application/msword\
      |application/vnd.openxmlformats-officedocument.*\
      |application/vnd.oasis.opendocument.text\
      |application/vnd.ms-excel\
      |text/rtf) handlr open $fx ;;
    (application/vnd.sqlite3) litecli $fx ;;
    (text/*|application/pgp-(encrypted|keys)) $EDITOR $fx ;;
    (image/x-xcf) setsid -f gimp $f >/dev/null 2>&1 ;;
    (image/svg+xml|image/*) rotdir $f \
      | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|tif\|ico\|svg\)\(_large\)*$" \
      | setsid -f nsxiv -aio 2>/dev/null | lf-select ;;
    (audio/*) mpv --vo=null --video=no --no-video --term-osd-bar --no-resume-playback  $f >/dev/null ;;
    (video/*) setsid -f mpv $f -quiet >/dev/null 2>&1 ;;
    (application/x-bittorrent) handlr open $fx ;;
    (application/zlib) handlr open $fx ;;
    (*)
      # (*.(a|ace|alz|ar|arc|arj|bz|bz2|cab|cpio|deb|cpt|deb|dgc|dgm|iso)\
      # |.*(jar|lha|lz|lzh|lzma|lzo|msi|pkg|rar|rpm|rz|shar|t7z|tar|tbz|tbz2|tgz)\
      # |.*(tlz|txz|tZ|tzo|war|xar|xpi|xz|Z|zip))
      case "$f" in
        (*.dmg) (( $+commands[hdiutil] )) && hdiutil attach "$fx" ;;
        (*.(tar.bz|tar.bz2|tbz|tbz2|tar.gz|tgz|tar.xz|txz|zip|rar|iso))
          mntdir="${f}-archivemount"
          [[ ! -d "$mntdir" ]] && {
            command mkdir "$mntdir"
            archivemount "$f" "$mntdir"
            builtin print -R "$mntdir" >> "/tmp/__lf_archivemount_${id}"
          }
          lf -remote "send $id cd '$mntdir'"
          lf -remote "send $id reload"
        ;;
        (*)
          handlr open $fx
        ;;
      esac
      ;;
  esac

  # mpv --audio-display=no
  # *) for f in $fx; do setsid -f $OPENER $f >/dev/null 2>/dev/null & done;;
}}

# === Opener: manually type in program =========================
cmd open-with %"$@" "$fx"

# === Opener: text-file script =================================
cmd wim $wim "$1"

# === Config ======================================== [[[
# === Config: lfrc ==================================
cmd edit_config :{{
  $$EDITOR ~/.config/lf/lfrc
  source ~/.config/lf/lfrc
}}


# === Config: lf scope ==============================
cmd edit_scope :{{
  $$EDITOR ~/.config/lf/scope
  source ~/.config/lf/scope
}}
# ]]] Config
# ]]] File Openers

# === File Movement ============================================ [[[
# === Trash: (rip) =============================================
cmd trash ${{
  setopt extendedglob
  local MATCH
  local -a arr short
  # Turn into an array
  arr=( "${(f)fx}" )
  # Since brackets are only able to be used once in lf, get tail here
  short=( ${arr:t2} )
  rip -- $fx
  dunstify -a lf " Deleted File(s)" "${(F)short}" && {
     print -Prl ${arr//(#m)*/%F{3}%B*%b %F{14}%U$MATCH%u%f: [%F{1}%Bdeleted%f%b]} \
       | hck -d ':' -D $'\t'
  }
}}

# === Move: zoxide =============================================
cmd move-file-jump ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local dest x; clear
  dest=$(_ZO_FZF_OPTS="$LF_FZF_OPTS --prompt ' Move to> '" \
      zoxide query -i || { dunstify "No file selected"; exit })
  for x (${=fx}) {
    command mv -iv -- "$x" $dest && \
      dunstify -a lf " File(s) moved" "${x:t} => $dest"
  }
}}

# === Move: path ===============================================
cmd move-file-manual ${{
  zmodload -Fa zsh/zle b:vared
  local x dest; clear
  vared -cp "Move to: " dest
  for x (${=fx}) {
    command mv -iv -- "$x" $~dest && \
      dunstify -a lf " File(s) moved" "${x:t} => $dest"
  }
}}

# === Copy: zoxide =============================================
cmd copy-file-jump ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local x dest; clear
  dest=$(_ZO_FZF_OPTS="$LF_FZF_OPTS --prompt ' Copy to> '" \
      zoxide query -i || { dunstify "No file selected"; exit })
  for x (${=fx}) {
    command cp -pivr -- "$x" $dest && \
      dunstify -a lf " File(s) copied" "${x:t} => $dest"
  }
  lf -remote "send clear"
}}

# === Copy: path ===============================================
cmd copy-file-manual ${{
  zmodload -Fa zsh/zle b:vared
  local x dest; clear
  vared -cp "Copy to: " dest
  for x (${=fx}) {
    command cp -pivr -- "$x" $~dest && \
      dunstify -a lf " File(s) copied" "${x:t} => $dest"
  }
  lf -remote "send clear"
}}

# === Link: script to home's bin ===============================
cmd link-homebin ${{
  for file (${=fx}) {
    [[ ! -x "$file" ]] && {
      lf -remote "send $id echoe '%B$file%b is not executable'"
      continue
    }
    command ln -siv -- "$file" "$HOME/bin/" && \
      dunstify -a lf " Linked to \$HOME/bin" "${file:t} => $HOME/bin/${file:t}"
  }
  lf -remote "send clear"
}}

# === Rsync ========================================= [[[
# === Rsync: copy files to my server ===========================
cmd rsyncto ${{
  for file (${=fx}) {
    rsync -uvrP "$file" root@lmburns.com:"$1" && \
      dunstify -a lf " Copied to server" "${file:t} => root@lmburns.com:$1"
  }
}}
# === Rsync: copy files from my server =========================
cmd rsyncfrom ${{
  rsync -uvrP root@lmburns.com:"$1" "${2:-$PWD}" && \
      dunstify -a lf " Copied from server" "root@lmburns.com:$1 => ${2:-$PWD}/${1}"
}}

# === Rsync: copy files to my mac ==============================
cmd rsync_to_mac ${{
  for file (${=fx}) {
    rsync -uvrP "$file" macbook:/Users/lucasburns/"$1" && \
      dunstify -a lf " Copied to macbook" "${file:t} => macbook:/Users/lucasburns/$1"
  }
  lf -remote "send clear"
}}
# === Rsync: copy files from my mac ============================
cmd rsync_from_mac ${{
  rsync -uvrP macbook:/Users/lucasburns/"$1" "${2:-$PWD}" && \
      dunstify -a lf " Copied from macbook" "macbook:/Users/lucasburns/$1 => ${2:-$PWD}/${1}"
}}
# ]]] Rsync
# ]]] File Movement

# === Archive ================================================== [[[
# === Unmount: unmount archivemount ============================
cmd unmount ${{
  fusermount -uz "$f" && dunstify -a lf " Unmounted Archive" "${f:t3}"
  command rmdir "$f"
  lf -remote "send $id reload"
}}

# === Archive: unarchive =======================================
cmd unarchive ${{
  xcompress x -- "${=fx}"
}}

# === Archive: archive =========================================
cmd archive %{{
  local archive_t
  print -Prn "%F{52}%BArchive%b%f: "
  read -r archive_t
  [[ -n "$archive_t" ]] && {
    xcompress a -o "$archive_t" -- $fx && {
      lf -remote "send $id unselect"
      lf -remote "send $id reload"
    }
  } || lf -remote "send $id echoe 'argument is required'"
}}
# ]]] Archive

# === Yank / Copy / Paste ====================================== [[[
# === Symlinks: hard and soft ==================================
# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
  zmodload -Fa zsh/files b:zf_rm
  local mode
  set ${(@f)"$(<$XDG_DATA_HOME/lf/files)"}
  mode="$1"
  shift
  if (( $# < 1 )); then
    lf -remote "send $id echoe 'no files to link'"
    exit 0
  fi
  case "$mode" in
    (copy)
      command ln -sr -t . "$@"
      dunstify -a lf "Created symlink" "${@:t3}\n=> $PWD"
    ;;
    (move)
      command ln -t . "$@"
      dunstify -a lf "Created hardlink" "${@:t3}\n=> $PWD"
    ;;
  esac
  zf_rm "${XDG_DATA_HOME}/lf/files"
  lf -remote "send clear"
}}

# === Paste: asynchronously ====================================
# TODO: test
cmd paste-async &{{
  zmodload -Fa zsh/files b:zf_rm
  local mode
  set ${(@f)"$(<$XDG_DATA_HOME/lf/files)"}
  mode="$1"
  shift
  case "$mode" in
    (copy)
      rsync -av --ignore-existing --progress -- "$@" . \
        | stdbuf -i0 -o0 -e0 tr '\r' '\n' \
        | while IFS= read -r line {
            lf -remote "send $id echo $line"
        }
      ;;
    (move) command mv -n -- "$@" .;;
  esac
  zf_rm "${XDG_DATA_HOME}/lf/files"
  lf -remote "send clear"
}}

# === Copy: follow symlink =====================================
# TODO: Finish when copy accepts argument
cmd copy-realpath ${{
  local origin
  origin="$(realpath -- "$fx")"
  lf -remote "send $id copy '$origin'"
}}

# === Yank: full file path =====================================
cmd yank-path ${{
  print -r "$fx" \
    | xclip -r -selection c && dunstify -a lf "File Path" "$fx\nCopied to clipboard"
}}
# === Yank: file basename ======================================
cmd yank-name ${{
  print -r "${fx:t}" \
    | xclip -r -selection c && dunstify -a lf "File Name" "${fx:t}\nCopied to clipboard"
}}
# === Yank: current directory name =============================
cmd yank-dir ${{
  print -r "$PWD" \
    | xclip -r -selection c && dunstify -a lf "Directory" "$PWD\nCopied to clipboard"
}}
# === Yank: full file path (absolute) ==========================
cmd yank-realpath ${{
  local origin
  origin="$(realpath -- "$fx")"
  print -r "$origin" \
    | xclip -r -selection c && dunstify -a lf "Absolute File Path" "$origin\nCopied to clipboard"
}}
# ]]] Yank / Copy / Paste

# === File Attributes ========================================== [[[
# === Permissions: change ======================================
cmd chmod %{{
  # zmodload -Fa zsh/zle b:vared
  # local perm; clear
  # vared -cp "Change permissions: " perm

  local perm
  print -Prn "%F{52}%BPermission%b%f: "
  read -r perm
  [[ -n "$perm" ]] && {
    chmod -- $perm $fx && {
      lf -remote "send $id reload"
      lf -remote 'send clear'
    }
  } || lf -remote "send $id echoe 'argument is required'"
}}

# === Ownership: change ========================================
cmd chown %{{
  local owner
  print -Prn "%F{52}%BOwner%b%f: "
  read -r owner
  [[ -n "$owner" ]] && {
      chown -- $owner $fx && {
    }
  } || lf -remote "send $id echoe 'argument is required'"
}}

# === Symlinks: harden =========================================
# Turn a symlink into a real file
cmd harden ${{
  for file ($fx) {
    harden "$file"
  }
  lf -remote "send unselect"
  lf -remote "send clear"
}}

# === Renaming ====================================== [[[
cmd massren $massren $fx
cmd mmv $mmv -- ${${(@f)fx}:t}
cmd f2 !f2 -f "$1"
cmd rmspace $f2 -f '\s' -r '_' -RFx

# === Rename: swap filenames ========================
cmd swap ${{
  local -a files; files=( ${(@f)fx} )
  (( $#files != 2 )) && { lf -remote "send $id echoe 'two filenames are required'" }
  renameat2 -e $files[1] $files[2]
}}

# === Backup: using numbered and simple VCS =========
cmd backup ${{
  local fl
  for fl ($=fx) {
    command cp -vruT --preserve=all --force --backup=existing -- $fl $fl
  }
}}

# === Backup: 'fname_2023-01-30T14:23-06:00' ========
cmd backup_date_iso ${{
  local fl ext
  for fl ($=fx) {
    ext=${fl:e}
    ext=${ext:+.$ext}
    ext=${ext:-}
    command cp -ivuT --preserve=links,mode,ownership,xattr "$fl" "${fl:r}_$(date --iso-8601=m)${ext}"
  }
}}

# === Backup: 'fname_2023_01_30' ====================
cmd backup_date_today ${{
  local fl ext
  for fl ($=fx) {
    ext=${fl:e}
    ext=${ext:+.$ext}
    ext=${ext:-}
  }
  # --preserve=all timestamp
  command cp -iv --preserve=links,mode,ownership,xattr "$fl" "${fl:r}_$(date '+%Y_%m_%d')${ext}"
}}
# ]]] Renaming

# === Attributes: directory size, etc. =========================
cmd disk-info ${{
  clear;
  local pth=$(pwd | lscolors)
  local cwd=${(l:(COLUMNS-$#PWD)/2:: :):-}$pth
  print -- "${cwd}\n$(dust | sed -E '1 s/^\s+//g')" \
    | bat --paging=always --pager="$LF_LESS" -f --style=grid

  # diskus
}}
# ]]] File Attributes

# === File / Directory Creation ================================ [[[
# === Creation: 1+ directories =================================
cmd mkdir %{{
  # Create a directory/directories
  setopt unset
  [[ -n "${1}" ]] && command mkdir -p "${@}" || lf -remote "send $id echoe 'no argument given'"
}}

# === Creation: 1+ files =======================================
cmd mkfile %{{
  # Create a file/files
  setopt unset
  [[ -n "${1}" ]] && touch "${@}" || lf -remote "send $id echoe 'no argument given'"
}}

# === Creation: directory & CD into it =========================
cmd take %{{
  # Create a folder & cd into it
  setopt unset
  [[ -n "${1}" ]] && {
    command mkdir -p "${@}" && lf -remote "send $id cd \"$@\""
  } || lf -remote "send $id echoe 'no argument given'"
}}

# === Creation: directory & move selected files into it ========
cmd newfold %{{
  # Create dir and move selected files into it
  local fold
  print -Prn "%F{52}%BFolder%b%f: "
  read -r fold
  dunstify "$fold"
  [[ -n "$fold" ]] && {
    command mkdir -p -- "$fold" && command mv -- $fx "$fold"
  } || lf -remote "send $id echoe 'no argument given'"

  # read -rq "?Overwrite? [y/n]? " answer

  # zmodload -Fa zsh/zle b:vared
  # clear; vared -cp "Folder: " fold
  # [[ -n "$fold" ]] && command mkdir -p -- "$fold" && command mv -- $fx "$fold"
}}
# ]]] File / Directory Creation

# === GPG ====================================================== [[[
# === GPG: encrypt recipient ===================================
cmd gpg_encrypt_recipient %{{
  zmodload -Fa zsh/zle b:vared
  local recipient; clear
  vared -cp "Recipient: " recipient
  case "$recipient" in
    ("") lf -remote "send $id echom 'no recipient given'";;
    (*)
      for file (${=fx}) {
        [[ -d "$file" ]] && {
          gpgtar --encrypt --create --output "${fx}.asc" --recipient "$recipient" -- "$file"
        } || gpg --encrypt --sign --recipient "$recipient" -- "$file"
      }
      ;;
  esac
}}

# === GPG: encrypt symmetric ===================================
cmd gpg_encrypt_pass ${{
  for file (${=fx}) { gpg --symmetric -- "$file" }
}}

# === GPG: encrypt self ========================================
cmd gpg_encrypt_self ${{
  for file (${=fx}) { gpg --encrypt -- "$file" }
}}

# === GPG: decrypt =============================================
cmd gpg_decrypt ${{
  for file (${=fx}) { gpg --output "${f%.*}.txt" --decrypt -- "$file" }
}}

# === GPG: sign ================================================
cmd gpg_sign ${{
  for file (${=fx}) { gpg --sign -- "$file" }
}}

# === GPG: sign detach =========================================
cmd gpg_sign_detach ${{
  for file (${=fx}) { gpg --sign --detach-sign -- "$file" }
}}

# === GPG: clearsign file ======================================
cmd gpg_sign_clear ${{
  for file (${=fx}) { gpg --clearsign -- "$file" }
}}

# === GPG: encrypt dir self ====================================
cmd gpg_encrypt_dir_self ${{
  for dir (${=fx}) { gpgtar --encrypt --output "${dir:t}.asc" -- ${dir:t} }
}}

# === GPG: decrypt dir =========================================
cmd gpg_decrypt_dir ${{
  for dir (${=fx}) { gpgtar --decrypt "$dir" }
}}

map ter gpg_encrypt_recipient
map tep gpg_encrypt_pass
map tes gpg_encrypt_self
map ted gpg_encrypt_dir_self
map tdf gpg_decrypt
map tdd gpg_decrypt_dir
map tss gpg_sign
map tsd gpg_sign_detach
map tsc gpg_sign_clear

map tT $gpg-tui # gpg-tui
# ]]]

# === Diff ===================================================== [[[
# === Diff: between two files ==================================
cmd diff_files ${{
  local -a files; files=( ${(@f)fx} )
  (( $#files != 2 )) && { lf -remote "send $id echoe 'two filenames are required'" }
  clear; delta $files[1] $files[2]
}}

# === Diff: nvim ===============================================
cmd nvim_diff ${{
  local -a files; files=( ${(@f)fx} )
  (( $#files != 2 )) && { lf -remote "send $id echoe 'two filenames are required'" }
  clear; nvim -d +0 $files
}}

map D diff_files
map df nvim_diff
# ]]] Diff

# === Selecting ================================================ [[[
# === Select: all files ========================================
cmd select-files ${{
  local -a files; files=( ${(@f)"$(fd . -L -d1 -tf)"} )
  for fi in "${files[@]}"; do
    lf -remote "send $id toggle $fi"
  done
}}

# === Select: all dirs =========================================
cmd select-dirs ${{
  local -a files; files=( ${(@f)"$(fd . -L -d1 -td)"} )
  for d in "${files[@]}"; do
    lf -remote "send $id toggle $d"
  done
}}

# === Select: all executables ==================================
cmd select-exec ${{
  local -a files; files=( ${(@f)"$(fd . -L -d1 -tx)"} )
  for x in "${files[@]}"; do
    lf -remote "send $id toggle $x"
  done
}}

# === Select: all files and dirs ===============================
cmd select-all :{{
  unselect; invert
}}

# === Select: any file interactively ===========================
cmd select-files-fzf ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  for f ($(\
      print -ln -- *(ND) \
        | lscolors \
        | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS -m" fzf || { dunstify "No files selected"; exit })
  )) {
    lf -remote "send $id toggle $f"
  }
}}

# === Select: follow symlink ===================================
cmd select-realpath ${{
  local origin
  local -a files; files=( ${(@f)fx} )
  (( $#files != 1 )) && { lf -remote "send $id echoe 'only one filename is allowed'" }
  origin=${files[1]:A}
  lf -remote "send $id select '$origin'"
}}

# === Select: builtin find (match can be anywhere in fname) ====
# cmd find-noanchor :{{ set noanchorfind; find; set anchorfind; }}
cmd find-noanchor ${{
  setopt localtraps; trap "lf -remote 'send $id set anchorfind'" EXIT
  lf -remote "send $id set noanchorfind"
  lf -remote "send $id find"
}}
# ]]] Selecting

# === Bookmarks ================================================ [[[
# === Bookmark Jump: specifically for lf =======================
cmd njump ${{
  bookmarks="${XDG_DATA_HOME}/lf/bookmarks"
  jump_file=$(mktemp -u --tmpdir "lf-jump.XXXXX")
  trap 'rm "$jump_file"' INT QUIT TERM EXIT
  fd -Hi -d1 -td -c never > "$jump_file"
  [[ -r "$bookmarks" ]] && cat "$bookmarks" >> "$jump_file"

  target=$(fzf --no-info --pointer=cd \
    --header="Jump to location" < <(sort -Vu "$jump_file"))
  lf -remote "send $id cd '$target'"
}}

# === Bookmark: specifically for lf ============================
cmd nbookmark ${{
  bookmarks_file="${XDG_DATA_HOME}/lf/bookmarks"
  bookmark_path="${f%/*}"
  command mkdir -p "$(dirname -- "$bookmarks_file)")"
  echo "${bookmark_path}" >> "$bookmarks_file"
  sort -u "$bookmarks_file" > "$bookmarks_file.$$"
  command mv -f "$bookmarks_file.$$" "$bookmarks_file"
  lf -remote "send $id echomsg Bookmark to '$bookmark_path' created."
}}

# === Bookmark: delete =========================================
cmd ndel-bookmark ${{
  bookmarks_file="${XDG_DATA_HOME}/lf/bookmarks"
  pth=$(cat "${bookmarks_file:?}" | fzf --no-sort)
  sd "$pth\n" "" "${bookmarks_file:?}"
  lf -remote "send $id echomsg Bookmark $pth deleted."
}}
# ]]] Bookmarks

# === CD ======================================================= [[[
# === Jump: zoxide =============================================
cmd fzf_zoxide ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local sel; clear
  sel="$(_ZO_FZF_OPTS="$LF_FZF_OPTS" zoxide query -i || { dunstify "No directory selected"; exit })"
  [[ -d "$sel" ]] && lf -remote "send $id cd \"$sel\""
}}

# === Tag Jump: builtin lf tags ================================
cmd jump_tag ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local tags="${XDG_DATA_HOME}/lf/tags"; clear
  [[ ! -r $tags ]] && {
    dunstify "No tag file found"
    return
  }

  local target=$(\
    column -t -s':' $tags | sort -k 2,2 \
      | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Jump> '" fzf \
        || { dunstify "No tag selected"; exit }) \
      | hck -f1
  )

  if [[ -d "$target" ]]; then
    lf -remote "send $id cd '$target'"
  elif [[ -n "$target" ]]; then
    lf -remote "send $id cd '${target:h}'"
  fi
}}

# === Jump: ====================================================
cmd jumpInteractive ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  zmodload -Fa zsh/parameter p:commands
  clear
  local field esc N R G Y B pattern res
  field='\(\S\+\s*\)'
  esc=$'\e'
  N="${esc}[0m"
  R="${esc}[31m"
  G="${esc}[32m"
  Y="${esc}[33m"
  B="${esc}[34m"
  pattern="s#^${field}${field}${field}${field}#$Y\1$R\2$N\3$B\4$N#"

  [[ -v commands[dasel] && -f $XDG_DATA_HOME/rualdi/rualdi.toml ]] && {
    res=$(\
      dasel -f $XDG_DATA_HOME/rualdi/rualdi.toml -s '.aliases' \
        | perl -pe 's{ = }{ → }; s/"//g' | nl | column -t \
        | sed "${pattern}" \
        | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS" \
            fzf --ansi \
                --preview='\
                f={}; bkt -- exa -T --color=always -L3 -- $(sed "s#.*→  ##" <<<"$f")' \
              --preview-window="right:50%" \
            || { dunstify 'No bookmark selected'; exit }) \
        | sed 's#.*→  ##')
    [[ -d "$res" ]] && lf -remote "send $id cd \"$res\""
  }
}}

# === CD: using FZF (depth=1) ==================================
cmd fzf_cd ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local ret; clear
  ret="$(fd . -d1 -td -HiL \
    | lscolors \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Cd> '" fzf \
        || { dunstify "No directory selected"; exit }))"
  lf -remote "send $id cd '$ret'"
}}

# === CD: using FZF (depth=~) ==================================
cmd fzf_cd_depth ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local ret; clear
  ret="$(fd . -d4 -td -HiL \
    | lscolors \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Cd> '" fzf \
        || { dunstify "No directory selected"; exit }))"
  lf -remote "send $id cd '$ret'"
}}

# === CD: using FZF find file and CD dir =======================
cmd fzf_cd_file ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local ret parent; clear
  ret="$(fd . -tf -HiL \
    | lscolors \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS --prompt='Cd> '" fzf \
        || { dunstify "No directory selected"; exit }))"
  [[ -f "$ret" ]] && {
    parent="${ret:h}"
    lf -remote "send $id cd '$parent'"
  }
}}

# === CD: follow symlink =======================================
cmd cd-realpath ${{
  local origin
  local -a files; files=( ${(@f)fx} )
  (( $#files != 1 )) && { lf -remote "send $id echoe 'only one filename is allowed'" }
  # origin="$(realpath -- "$fx")"
  origin=${files[1]:A}
  lf -remote "send $id cd '$origin'"
}}
# ]]] CD

# === TAGS ===================================================== [[[
# === Tag: tmsu set ============================================
cmd tmsu-set ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet -t tmsu)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Set tag: " tmsu_tag
  tmsu tag --tags="$tmsu_tag" $fx
}}

# === Tag: tmsu list specific file =============================
cmd tmsu-remove ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet -t tmsu)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Remove tag: " tmsu_tag
  tmsu untag --tags="$tmsu_tag" $fx
}}

# === Tag: tmsu remove =========================================
cmd tmsu-list !{{
  clear
  tmsu tags "$fx" | bat -pfl bash --paging=always
}}

# === Tag: wutag set ===========================================
cmd wutag-set ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet -t wutag)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Set tag: " tag
  for x in $fx; do
    fname="${x:t}"; fdir="${x:h}"
    wutag -d "${fdir}/" set -c $fname $tag
  done
}}

# === Tag: wutag add ===========================================
cmd wutag-add ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet -t wutag)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Add tag: " tag
  for x in $fx; do
    fname="${x:t}"; fdir="${x:h}"
    wutag -d "${fdir}/" set $fname $tag
  done
}}

# === Tag: wutag remove ========================================
cmd wutag-remove ${{
  zmodload -Fa zsh/zle b:vared
  clear
  print -nPr "%F{2}"
  print -f "%s" "$(figlet -t wutag)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Remove tag: " tag
  for x in $fx; do
    fname="${x:t}"; fdir="${x:h}"
    wutag -d "${fdir}/" rm $fname
  done
}}

# === Tag: wutag list ==========================================
cmd wutag-list ${{
  clear
  noglob wutag --color=always list files -tf | bat -pf --paging=always
}}
# ]]] TAGS

# === Finding ================================================== [[[
# Find file with pattern
cmd fzf $clear; nvim $(fd -Hi -tf "$1" . |  fzf --no-height)
# Find file with fd
cmd fd ${{
  clear; fd --color=always -Hi "$@" | bat -fp --paging=always
}}
# Find recently changed file
cmd fdr ${{
  clear; fd --color=always -Hi -d1 --changed-within="$1" | bat -fp --paging=always
}}
# Normal grep command
cmd rg ${{
  clear; rg --color=always "$@" | bat -fp --paging=always
}}
# Grep with FZF
cmd rgu ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  clear;
  FZF_DEFAULT_OPTS="$LF_FZF_OPTS" rgu "$1"
}}
# Grep through many kinds of files
cmd rga ${{
  clear; rga --color=always "$@" | bat -fp --paging=always
}}

# === FZF: edit file ===========================================
cmd fd_edit ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local -a files; clear
  files=( ${(@f):-"$(command fd -Hi -tf .)"} )
  print -rl -- "$files[@]" | lscolors \
    | FZF_DEFAULT_OPTS="$LF_FZF_OPTS" \
    fzf --multi \
      --select-1 \
      --exit-0 \
      --bind='ctrl-e:become($EDITOR {})' \
      --bind='enter:become($EDITOR {})' \
      --preview-window=':nohidden,right:65%:wrap' \
      --preview='([[ -f {} ]] && (bat --style=numbers --color=always {})) || ([[ -d {} ]] && (exa -TL 3 --color=always --icons {} | less)) || echo {} 2> /dev/null | head -200'
}}

cmd packer ${{
  # fpath=( ${0:h}/{functions,completions} "${fpath[@]}" )
  # autoload -Uz $fpath[1]/*(:t)

  dunstify "$Z"
}}

map fp packer
# ]]] Finding

# === Miscellaneous ============================================ [[[
# TODO: Use and add make / cargo
# === Script: run a node script ================================
cmd node_script ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local script; clear
  script=$(cat package.json | jq -r '.scripts | keys[] ' | sort \
      | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fzf))
  [[ -n "$script" ]] && npm run $(print -r -- "$script")
}}

# TODO: FINISH
# === Checksum: get the checksum of a file or directory ========
cmd chksum ${{
  zmodload -Fa zsh/zle b:vared
  local chksum_resp chksum

  chksum="blake3"

  clear
  print -nPr "%F{21}"
  print -f "%s" "$(figlet -t checksum)"
  print -Pr "%f"
  print -r ${(l:COLUMNS::=:):-}
  print
  vared -cp "Possibilities: MD5, SHA1, SHA224, SHA256, SHA384, SHA512, BLAKE3 Create MD5 (m), SHA256 (s), SHA512 (S), BLAKE3 (b) (or type one of the above) [default=b]: " chksum_resp

  if [[ $chsum_resp = "s" ]]; then
    chsum=sha256
  elif [[ $chsum_resp = "S" ]]; then
    chsum=sha512
  fi

  case "$chksum" in
    (m) chksum="md5"    ;;
    (s) chksum="sha256" ;;
    (S) chksum="sha512" ;;
    (*) chksum="blake3" ;;
  esac
}}

map C chksum
# ]]] Miscellaneous


# === External ================================================= [[[
# === Dragon ======================================== [[[
cmd dragon %dragon -a -x $fx
cmd dragon-stay %dragon -a $fx
cmd dragon-individual %dragon $fx
cmd cpdragon %cpdragon
cmd mvdragon %mvdragon
cmd dlfile %dlfile
# ]]] Dragon


# === Download: with xh =============================
cmd download-file ${{
  xh --pretty=all --style=auto --timeout=10 --download "$(xsel -b)"
}}
# ]]] External

# === ZLE ====================================================== [[[
# === ZLE: change directories ===================================
cmd zle-cd %{{
  print -l -- "_p9k_precmd; builtin cd "$PWD"; zle reset-prompt; zle -R" >&$ZLE_FIFO
}}

# === ZLE: insert path into CLI =================================
cmd zle-insert-relative %{{
  for f ($fx) {
    print -l -- "LBUFFER+=${LBUFFER:+ }${(q)$(realpath "$f" --relative-to=$PWD)}" >&$ZLE_FIFO
  }
}}

# === ZLE: insert abspath into CLI =============================
cmd zle-insert-absolute %{{
  for f ($fx) {
    print -l -- "LBUFFER+=${LBUFFER:+ }${f}" >&$ZLE_FIFO
  }
}}

# === ZLE: initialize ==========================================
cmd zle-init :{{
  map , zle-cd
  map ap zle-insert-relative
  map aP zle-insert-absolute
}}

&[[ -n "$ZLE_FIFO" ]] && lf -remote "send $id zle-init"
# ]]] ZLE
# ]]]

# ╭──────────────────────────────────────────────────────────╮
# │                         Mappings                         │
# ╰──────────────────────────────────────────────────────────╯ [[[

# === Unmappings =============================================== [[[
# map n
# map "'"
# map '"'
map m
map M
map d
map O
map e
map w
map i
map c
map f
map gh
map .
map r
map t
map <c-l>
map H
map L
map v
map ]
map [
# ]]] Unmappings

# === General ================================================== [[[
map . set hidden!         # toggle hidden files
map <space> :toggle; down # toggle selection and move down
map <tab> :toggle; down   # toggle selection and move down
map <backtab> :toggle; up # toggle selection and move up

map @ :terminal
map <a-$> :dump-env
map <esc> quit # quit lf
map ZZ quit    # quit lf
map R reload   # reload lf
map <c-n> &{{
  # redraw lf
  lf -remote "send $id redraw"
  lf -remote "send $id echom 'Redrawn'"
}}

# === Cursor Movement =============================== [[[
map gg top -- []   # move to the top
map G bottom -- [] # move to the bottom
map J half-down    # move halfway down
map K half-up      # move halfway up
# ]]] Cursor Movement

# === Sorting / Preview ============================= [[[
map sR :{{ set reverse!; }}                    # reverse file order

map s1 :{{ set preview;   set ratios 1:2:3; }} # set display (preview)
map s2 :{{ set preview;   set ratios 1:2; }}   # set display (no preview)
map s3 :{{ set nopreview; set ratios 1:3; }}   # set display (preview)

map sn :{{ set sortby natural; set info size; set noreverse; }} # revert back to normal sort
map sa :{{ set sortby atime; set info atime; set reverse; }}
map sc :{{ set sortby ctime; set info ctime; set reverse; }}
map st :{{ set sortby time; set info time; set reverse; }}
map se :{{ set sortby ext; set info; set noreverse; }}

map S :{{
  # revert sort back to normal
  set sortby natural; set info size;     set noreverse ;
  set preview;        set ratios 1:2:3;
}}
# ]]] Sorting / Preview
# ]]] General

# === Cut / Copy / Paste ======================================= [[[
map x cut                     # general cut
map p paste                   # regular
map Pl :{{ link; unselect; }} # paste a symlink
map Pa paste-async            # paste a file asynchronously (used for big files)

map y copy           # copy file
map Yr copy-realpath # copy file from absolute path

map Yb link-homebin  # link file to ~/bin

map YR yank-realpath # yank absolute path
map Yp yank-path     # yank file path
map Yn yank-name     # yank name of file path
map Yd yank-dir      # yank name of directory

map Yu ${{
  # yank URL of git repo
  ngu
}}
map Ya ${{
  # yank author of git repo
  nga
}}

# TODO: Finish
# paste a file and make sure its not a symlink
map Ph ${{
  zmodload -Fa zsh/files b:zf_rm
  local ofile nfile
  lf -remove load
  lf -remote "send $id paste"
  # ofile=${${(@f)"$(<$XDG_DATA_HOME/lf/files)"}[2]}
  # nfile="${PWD}/${ofile:t}"
  # lf -remote "send $id select '$nfile'"
  # harden "$nfile"

  # zf_rm "${XDG_DATA_HOME}/lf/files"
  # lf -remote "send clear"
}}
# ]]] Cut / Copy / Paste

# === File Openers ============================================= [[[
map ee $$EDITOR "$f"                                    # open file in editor
map Ev $vim "$fx"                                       # edit a file with vim
map ec edit_config                                      # edit & source lfrc
map es edit_scope                                       # edit lfrc scope
map ev $$EDITOR $NVIMRC                                 # open nvim config
map ew $$EDITOR $HOME/vimwiki/index.md                  # open vimwiki
map ez $$EDITOR $ZDOTDIR/.zshrc                         # edit zshrc
map eZ $$EDITOR $HOME/.zshenv                           # edit zshenv
map ea $$EDITOR $ZDOTDIR/zsh.d/aliases.zsh              # edit zsh aliases
map eb $$EDITOR $ZDOTDIR/zsh.d/keybindings.zsh          # edit zsh bindings
map ei $$EDITOR $ZDOTDIR/zsh.d/lficons.zsh              # edit lf colors/icons
map et $$EDITOR $XDG_CONFIG_HOME/tmux/tmux.conf         # edit tmux conf
map eo $$EDITOR $XDG_CONFIG_HOME/nvim/coc-settings.json # open coc-settings
map Et :nvim-tmux                               # edit file by opening split of tmux

map v ${{
  # bat view file
  clear; LESS='-iWQMXR~' bat --paging=always --theme=kimbro "$f"
}}
map ? ${{
  # open lfrc docs
  clear; batman lf
}}
map gH ${{
  # open lf mappings
  clear; bat -f --paging=always -l bash ~/.config/lf/mappings
}}
map Ow push :open-with<space>                       # open w/ specified program
map Op &{{
  # open curr directory in pcmanfm
  pcmanfm $PWD
}}
map o  ${{
  # handlr open ask
  clear; handlr ask --config $f
}}
map Oa ${{
  # mimeopen ask
  mimeopen --ask $f
}}
# map Oa $mimeopen $f

map Qm !{{
  # preview in mdcat
  clear; mdcat -p $fx
}}
map Qg !{{
  # preview in glow
  clear; glow -p $fx
}}
# ]]] File Openers

# === File Selection =========================================== [[[
map fo push :fzf<space>   # fzf search and open
map fd push :fd<space>    # use fd to find file
map fr push :fdr<space>   # use fd to find recent file
map fe fd_edit            # find files with fzf and edit (with preview)
map fa push :rga<space>   # search all files (including pdf etc) with rg
map <c-f> push :rg<space> # search with rg
map F push :rgu<space>    # search interactively with rg and fzf

map U unselect                # unselect all selected items
map , :{{ clear; unselect; }} # clear prev selection and unselect all
map V invert                  # inverset selection

map sf select-files
map sd select-dirs
map sx select-exec
map sA select-all
map sF select-files-fzf
map sr select-realpath

map ss set globsearch!            # toggle glob search
map sg push :glob-select<space>   # select files matching pattern
map sG push :glob-unselect<space> # unselect files matching pattern

map ff push :filter<space>
map rl find
map rh find-back
map ] find-next
map [ find-prev
# ]]] File Selection

# === File Movement ============================================ [[[
map Yj copy-file-jump              # copy to directory with zoxide
map Ym copy-file-manual            # copy to directory with path entered

map Mj move-file-jump              # move to directory with zoxide
map Mp move-file-manual            # move to directory with path

map Mt push :rsyncto<space>        # move things to the server
map Mf push :rsyncfrom<space>      # move things from the server
map Ml push :rsync_to_mac<space>   # move things to the macbook
map Mm push :rsync_from_mac<space> # move things from the macbook

map Ma $neomutt -a "$fx"           # mail a file
# ]]] File Movement

# === File Attributes ========================================== [[[
map -  harden # turn a symlink into a real file
map ch chmod  # change file permissions
map =  chmod  # change file permissions
map cH chown  # change file owner

map ad disk-info # get disk information
map as ${{
  # directory info
  clear; du -hsx * | sort -rh | bat --paging=always
}}
map ai !{{
  # file information
  clear; file-info $f
}}
map aI ${{
  # dua interactive
  dua i
}}

map Tk !{{
  # tokei - code count
  clear; tokei
}}
# ]]] File Attributes

# === File / Directory Creation ================================ [[[
map ms $mksc               # create script
map mf push :mkfile<space> # create file
map md push :mkdir<space>  # create dir
map mt push :take<space>   # create dir and cd into it
map mD newfold             # create dir and move selected files into it
# ]]] File / Directory Creation

# === Renaming ================================================= [[[
map cn push A<c-u>          # new rename
map A rename                # cursor at the very end
map I push A<c-a>           # cursor at the beginning
map i push A<a-b><a-b><a-f> # cursor before extention
map aa push A<a-b>          # cursor after extention

map bf push :f2<space>      # use f2 to rename
map bm massren              # bulk rename with massren
map bv mmv                  # bulk rename only with selected
map bs swap                 # swap two filenames
map bp rmspace              # remove spaces from filenames
map bc backup               # backup file with `cp`
map bdi backup_date_iso     # backup using ISO suffix
map bdt backup_date_today   # backup using today's date
# ]]] Renaming

# === CD ======================================================= [[[
map cc fzf_zoxide      # fzf zioxide
map ci jumpInteractive # rualdi fzf
map wd fzf_cd          # fzf cd (only lists directories)
map wf fzf_cd_file     # fzf cd to file parent (only lists files)
map W fzf_cd_depth     # fzf cd further depth

map <c-l> cd-realpath # cd to directory's realpath
map } cd-realpath     # cd to directory's realpath
map H jump-prev       # go to previous directory in history
map L jump-next       # go to next directory in history

map <lt> jump-prev       # go to previous directory in history
map <gt> jump-next       # go to next directory in history

map Bc cd ~/.config
map Bi cd /run/media/lucas
map bh cd ~
# ]]] CD

# === Archive ================================================== [[[
map aU unarchive
map aA archive
map au unmount
# ]]] Archive

# === Trash ==================================================== [[[
map dd trash                  # rip
map du %{{
  # undo last delete
  rip -u
}}
map de %{{
  # empty trash
  rip -d
}}
map dFl ${{
  # list trash with fzf
  clear; rip -as | FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fzf
}}
map dFm ${{
  # trash delete with fzf
  FZF_DEFAULT_OPTS="$LF_FZF_OPTS" frip
}}
map dFr ${{
  # fzf trash restore script
  FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fripu
}}

cmd rmsym ${{
  command rm -- *(-@D);
}}
cmd rmsymr ${{
command rm -- **/*(-@D);

}}
# ]]] Trash

# === Dragon =================================================== [[[
map drr dragon
map drs dragon-stay
map dri dragon-individual
map drm mvdragon
map drc cpdragon
map drl dlfile        # download file by dragging & dropping
map dl  download-file # download file from clipboard
# ]]] Dragon

# === Shell ==================================================== [[[
# map <c-s> shell                       # enter shell command
map <c-x>s shell-wait                   # enter shell cmd
map <c-x>x $$f                          # execute file
map <c-x>X !$f                          # execute file and $PAGER output
map <c-x>l $$f | bat --paging=always -f # execute file and bat output
map <c-x>w push :wim<space>             # open script source code
map <c-x>p $cat $fx | up                # cat file to up (unix piper)
# ]]] Shell

# === Tagging ================================================== [[[
# map <c-_> mark-save
# map ma mark-save
map <a-.> mark-save
map <a-'> mark-save
map "'" mark-load
map '"' mark-remove
# map ; :{{ mark-save "'"; }}

map <a-,> push :tag<space>
map X tag-toggle
map Tj jump_tag

map Tms tmsu-set
map Tmr tmsu-remove
map Tml tmsu-list

map Ts wutag-set
map Ta wutag-add
map Tr wutag-remove
map Tl wutag-list

map cJ njump         # lf specifc - jump bookmark
map cB nbookmark     # lf specifc - add bookmark
map cD ndel-bookmark # lf specifc - del bookmark
# ]]] Tagging

# === TUI ====================================================== [[[
map gTt $tig show # tig
map gTu $gitui    # git
map gL $lazygit   # git
map bo $bow       # buku bookmarks

# === Torrent ======================================= [[[
map toa $transmission-remote --add $fx # add torrent
map toT $tide                          # transmisison TUI
map tos $stig                          # transmisison TUI
# ]]] Torrent
# ]]] TUI

# === Git ====================================================== [[[
# === Git Commands ================================== [[[
cmd git_add $for x ($fx) { git add "$x" }
cmd git_branch ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  local pwd_shell; clear
  git branch \
    | (FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fzf) \
    | xargs git checkout
  pwd_shell=$(pwd)
  lf -remote "send $id updir"
  lf -remote "send $id cd \"$pwd_shell\""
}}

# Delete a git repo and reclone it
cmd git_reclone_repo ${{
  ngu
  rip -- *
  gh c $(xsel -b)
  t=$PWD:t
  command rsync -vua --delete-after ${t:?invalid current dir}/ .
}}

# Pull and rebase all git directories under the current dir
cmd mgit_pull_rebase !{{
  emulate -L zsh -o extendedglob
  zmodload -Fa zsh/zle b:vared
  local ans; clear
  print -Pr "%F{47}%B${(l:COLUMNS::=:):-}%b%f"
  print -nPr "%F{52}%B"
  print -r "$(figlet -tc Confirm)"
  print -rn "$(figlet -tc Rebase)"
  print -Pr "%b%f"
  print -Pr "%F{47}%B${(l:COLUMNS::=:):-}%b%f"
  print
  # lf -remote "send $id figlet Confirm Rebase"
  vared -cp 'Confirm rebase [Y/n]: ' ans
  [[ $ans == (#i)y(es|) ]] && mgit pull --rebase || return 0
}}
# ]]] Git Commands

# === Git Mappings ================================== [[[
map gta :{{ git_add; unselect; }}
map gtr :git_reclone_repo
map gtb :git_branch
map gtc ${{
  # git clone repo from clipboard
  clear; gclp
}}
map gtp !{{
  # git pull
  clear; git pull
}}
map gtP !{{
  # git pull --rebase
  clear; git pull --rebase
}}
map gtz !{{
  # git status
  clear; git status
}}
map gtl !{{
  # git log oneline
  clear; git la
}}
map gtL !{{
  # git log oneline stat
  clear; git lo
}}
map gl  ${{
  # git log full diff
  clear; git log -p
}}
map gts !{{
  # git log full diff+signature
  clear; git show --show-signature
}}
map go  &{{
  # open git repo URL
  git brws
}}

map gm :mgit_pull_rebase

# map gttr ${{clear; git ls-tree -r master --name-only | bat}}
# map gttt ${{clear; git ls-tree -r master --name-only | as-tree --color always | bat -p}}
# map gttu ${{clear; git ls-files --other | bat}}

# map gFd ${{clear; f::diff}}
# map gFc ${{clear; f::clean}}
map gfs ${{
  # fstat
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fstat
}}
map gfa ${{
  # fadd
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" fadd
}}
map gfl ${{
  # flog
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" flog
}}
map gfu ${{
  # funtrack
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" funtrack
}}
# ]]] Git Mappings

# === Dotbare (dotfiles) ======================================= [[[
# === Dotbare Commands ============================== [[[
cmd dotbare_add ${{
  setopt localtraps err_exit; trap "return 0" EXIT
  for x ($fx) { FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare add "$x" }
}}
# ]]] Dotbare Commands

# === Dotbare Mappings ============================== [[[
map gda :{{ dotbare_add; unselect; }}
map gdai ${{
  # dotbare fadd
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare fadd -f
}}
map gds ${{
  # dotbare fstat
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare fstat
}}
map gdu ${{
  # dotbare funtrack
  setopt localtraps err_exit; trap "return 0" EXIT
  clear; FZF_DEFAULT_OPTS="$LF_FZF_OPTS" dotbare funtrack
}}

# map gftr ${{clear; dotbare ls-tree -r master --name-only | bat}}
# map gftt ${{clear; dotbare ls-tree -r master --name-only | as-tree --color always | bat -p}}
# map gftu ${{clear; dotbare ls-files --other | bat}}
# ]]] Dotbare Mappings
# ]]] Dotbare (dotfiles)
# ]]] Git

# === Command Mode Mappings ==================================== [[[
cmap <c-j>
cmap <c-k>

cmap <a-i> set incsearch!     # toggle incremental search
cmap <a-g> set globsearch!    # toggle glob search
cmap <right> :cmd-enter; open # accept command and open file

cmap <esc>  cmd-escape             # quit command line mode
cmap <c-c>  cmd-interrupt          # end current shell-pipe command
cmap <tab>  cmd-complete           # show completion menu
cmap <a-.>  cmd-menu-complete      # show completion menu and select forward
cmap <a-,>  cmd-menu-complete-back # show completion menu and select backward
cmap <down> cmd-history-next       # scroll forward in history
cmap <up>   cmd-history-prev       # scroll backward in history
cmap <c-j>  cmd-history-next       # scroll forward in history
cmap <c-k>  cmd-history-prev       # scroll backward in history

cmap <c-b>  cmd-left  # move cursor left
cmap <c-f>  cmd-right # move cursor right
cmap <a-o>  cmd-left  # move cursor left
# cmap <a-i>  cmd-right # move cursor right
cmap <home> cmd-home  # move cursor beginning of line
cmap <end>  cmd-end   # move cursor end of line
cmap <c-s>  cmd-home  # move cursor beginning of line
cmap <c-e>  cmd-end   # move cursor end of line
cmap <lt>   cmd-home  # move cursor beginning of line
cmap <gt>   cmd-end   # move cursor end of line

cmap <a-f> cmd-word      # move forward one word
cmap <a-b> cmd-word-back # move backward one word

cmap <delete>    cmd-delete      # delete char to right of cursor
cmap <backspace> cmd-delete-back # delete char to left of cursor
cmap <c-h>       cmd-delete      # delete char to right of cursor
cmap <c-l>       cmd-delete-back # delete char to left of cursor

cmap <a-[> cmd-delete-home # delete all text to left of cursor
cmap <a-]> cmd-delete-end  # delete all text to right of cursor

cmap <a-c> cmd-delete-unix-word # delete word to left of cursor
cmap <c-w> cmd-delete-unix-word # delete word to left of cursor
cmap <a-d> cmd-delete-word      # delete word to right of cursor

cmap <c-y>   cmd-yank # yank cli text

cmap <a-p> cmd-capitalize-word # capitalize word
cmap <a-u> cmd-uppercase-word  # uppercase word
cmap <a-l> cmd-lowercase-word  # lowercase word

cmap <c-t> cmd-transpose      # transpose last two chars
cmap <a-t> cmd-transpose-word # transpose last two words
# ]]] Command Mode Mappings

# === Mouse Mappings =========================================== [[[
# map <m-1>
# map <m-2>
# map <m-3>
# map <m-4>
# map <m-5>
# map <m-6>
# map <m-7>
# map <m-8>

# map <m-1> down  # primary
# map <m-2> down  # secondary
# map <m-3> down  # middle

 # map <m-up>    down
 # map <m-down>  down
 # map <m-left>  down
# ]]] Mouse Mappings
# ]]] Mappings

# vim: ft=lf:et:sw=2:ts=2:sts=-1:fdm=marker:fmr=[[[,]]]:
