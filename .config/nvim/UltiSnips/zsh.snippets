priority 1

snippet #! "#!/usr/bin/env zsh" b
#!/usr/bin/env zsh
$0
endsnippet

snippet script "#!/usr/bin/env zsh" b
#!/usr/bin/env zsh
$0
endsnippet

snippet 0h "${0:h} zsh standard" b
0="${${ZERO:-\${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
0="${${(M)0:#/*}:-$PWD/\$0}"
$0
endsnippet

snippet 0h2 "${0:h} zsh standard alt" b
0="${${(M)\${0::=${(%):-%x}}:#/*}:-$PWD/$0}"
$0
endsnippet

snippet std "${0:h} zsh standard" b
0="${${ZERO:-\${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
0="${${(M)0:#/*}:-$PWD/\$0}"
$0
endsnippet

snippet hascmd "(( ${+commands[val]} )) && line" b
(( ${+commands[${1:cmd}]} )) && { ${2:$1} }
endsnippet

snippet hasfunc "[[ -v functions[val] ]] && line" b
(( ${+functions[${1:cmd}]} )) && { ${2:$1} }
endsnippet

snippet has "(( $+var )) && line"
(( ${+${1:variable}} )) && ${2:$1}
endsnippet

snippet hasv "[[ -v $var ]] && line"
[[ -v $${1:variable} ]] && ${2:$1}
endsnippet

snippet hascmdb "(( ${+commands[val]} )) && block"
(( \${+commands[${1:cmd}]} )) && {
	${2:$1}
}
endsnippet

snippet hasb "(( $+var )) && block"
(( \${+${1:variable}} )) && {
	${2:$1}
}
endsnippet

snippet hasvb "[[ -v $var ]] && block"
[[ -v \$${1:variable} ]] && {
	${2:$1}
}
endsnippet

snippet ist "(( VAL )) && block"
(( ${1:val} )) && {
	${2}
}
endsnippet

snippet isf "(( ! VAL )) && block"
(( ! ${1:val} )) && {
	${2}
}
endsnippet

# ========================== Variables ==========================
snippet default "Set default program" b
export ${1:EDITOR}="\${commands[${2:vim}]:-\$$1}"
endsnippet

snippet expp "typeset -gx var=" b
export ${1:var}=
endsnippet

snippet exp "typeset -gx var=" b
typeset -gx${1:flags} ${2:var}; $2=
endsnippet

snippet global "typeset -g var=" b
typeset -g${1:flags} ${2:var}; $2=
endsnippet

snippet local "local var=" b
local ${1:-flags} ${2:var}; $2=
endsnippet

snippet int "integer var=" b
integer ${1:int}; $1=
endsnippet

snippet float "float var=" b
# float [{+|-}Hghlprtux] [{+|-}EFLRZ [n]]
float ${1:int}; $1=
endsnippet

snippet priv "private var=" b
private ${1:-flags} ${2:var}; $2=
endsnippet

snippet reado "readonly var=" b
readonly ${1:-flags} ${2:var}; $2=
endsnippet

snippet let "let 'expr'" b
let '${1:var}'
endsnippet

snippet dass ": do assign" b
: ${1:var}
endsnippet

snippet uass ": unconditional assign" b
: ${${1:var}::=${2:val}}
endsnippet

snippet tern "String ternary" b
${${${${1:if}}:+${2:then}}:-${3:else}}
endsnippet

snippet ternm "Math ternary" b
$(( ${1:var} ? ${2:then} : ${3:else} ))
endsnippet

snippet ali "alias val=''" b
alias ${1:alias}='${2:value}'
endsnippet

snippet zmod "zmodload -Fa zsh/" b
zmodload -Fa zsh/${1:module}
endsnippet

snippet autol "autoload -Uz fun" b
autoload -Uz ${1:fun}
endsnippet

snippet autolthis "autoload current" b
fpath+=( $PWD/${1:file} )
autoload -Uz $1
endsnippet

snippet zmod "defer -t <time> -c fun" b
defer -t ${2:3} -c ${1:fun}
endsnippet

snippet cols "COLUMNS =====" b
${(l:COLUMNS${1:var}::=:):-}
endsnippet

# === Prefix ============================================================= [[[
snippet cmd "command {exec}" b
command ${1:exec}
endsnippet

snippet bui "builtin {exec}" b
builtin ${1:exec}
endsnippet

snippet emlr "emulate -LR zsh" b
emulate -LR zsh ${1:more}
endsnippet

snippet eml "emulate zsh -L + extglob" b
emulate zsh -L
builtin setopt extendedglob ${1:option}
endsnippet

snippet opts "Set options (warncreateglobal, etc.)" b
builtin emulate -L zsh
setopt extendedglob warncreateglobal typesetsilent \
				noshortloops rcquotes noautopushd
endsnippet

snippet optsx "Set options + xtrace (warncreateglobal, etc.)" b
builtin emulate -L zsh ${=${options[xtrace]:#off}:+-o xtrace}
setopt extendedglob warncreateglobal typesetsilent \
				noshortloops rcquotes noautopushd
endsnippet

snippet optw "Set warncreateglobal" b
builtin emulate -L zsh -o warncreateglobal
endsnippet
# ]]]

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

snippet matchm "Setup :#(#m)" b
${(M)${1:var}:#(#m)${2}}
endsnippet

snippet subm "Setup //(#m)" b
local MATCH; integer MBEGIN MEND
${${1:var}//(#m)${2}/$MATCH}
endsnippet

snippet matchb "Setup :#(#b)" b
${(M)${1:var}:#(#b)${2}}
endsnippet

snippet subm "Setup //(#b)" b
${${1:var}//(#b)${2}/${match[1]}}
endsnippet

snippet imppriv "Import private" b
zmodload -Fa zsh/param/private b:private
endsnippet

snippet impmr "Import match, reply" b
local MATCH REPLY; integer MBEGIN MEND
local -a match mbegin mend reply
endsnippet

snippet impm "Import match" b
local MATCH; integer MBEGIN MEND
local -a match mbegin mend
endsnippet

snippet impr "Import reply" b
local REPLY
local -a reply
endsnippet

snippet setr "Set reply to $@" b
set -- "$reply[@]"
endsnippet

# ========================== Conditions ==========================
snippet and "[[ TEST ]] &&" b
[[ ${1:condition} ]] && {
	${0:${VISUAL}}
}
endsnippet

snippet if "if condition" b
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet ife "if else condition" b
if ${1:condition}; then
	${2:${VISUAL}}
else
	${0:# statements}
fi
endsnippet

snippet eif "elif condition" b
elif ${1:condition}; then
	${0:${VISUAL}}
endsnippet

snippet for "c-style for loop" b
for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
	${0:${VISUAL}}
done
endsnippet

snippet fori "for (...) .." b
for ${1:item} (${2:list}[@]) {
	${0:${VISUAL}}
}
endsnippet

snippet foril "for .. in .. (long)" b
for ${1:needle} in ${2:haystack}; do
	${0:${VISUAL}}
done
endsnippet

snippet fore "foreach loop" b
foreach ${1:item} (${2:list}) {
	${0:${VISUAL}}
}
endsnippet

snippet forel "foreach .. end" b
foreach ${1:item} (${2:list})
	${0:${VISUAL}}
end
endsnippet

snippet wh "while loop" b
while ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet until "until loop" b
until ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet repeat "repeat loop" b
repeat ${1:integer} {
	${0:${VISUAL}}
}
endsnippet

snippet case "case statement" b
case ${1:word} {
	(${2:pattern})
		${0}
	;;
}
endsnippet

snippet casel "case statement (long)" b
case ${1:word} in
	(${2:pattern})
		${0}
	;;
esac
endsnippet

snippet select "select statement" b
select ${1:answer} in ${2:choices}; do
	${0:${VISUAL}}
done
endsnippet

snippet pa "parenthesis" b
(${0:#statements})
endsnippet

snippet pc "curly brace" b
{${0:#statements}}
endsnippet

snippet tst "test statement" b
[[ -${1:test} ${2:value} ]]
endsnippet

snippet always "always statement" b
{
	${1:# try}
} always {
	${0:# always}
}
endsnippet

snippet alwayst "always statement (try_block = 0)" b
{
	${1:# try}
} always {
  (( TRY_BLOCK_ERROR = 0 ))
	${0:# always}
}
endsnippet

snippet funs "function def short" b
${1:function_name}() {
	${0:# function_body}
}
endsnippet

snippet fun "function def" b
function ${1:function_name}() {
	${0:# function_body}
}
endsnippet

snippet afun "anon function def" b
() {
	${1:# function_body}
}
endsnippet

snippet _z "comp starter"
#compdef z

local arguments

__display(){
        _alternative \
        'aliases:command:(('"$(_z |& awk -v q=\' '{printf "%s\\:\"%s\" ", $2,$1}')"'))' \
        'files:directory:_path_files -g ".*(/) *(/)"'
}

arguments=(
       '-c[restrict matches to subdirectories of the current directory]'
       '-e[echo the best match, do not cd]'
       '-c[show a brief help message]'
       '-l[list only]'
       '-r[match by rank only]'
       '-t[match by recent access only]'
       '-x[remove the current directory from the datafile]'
        '1:command:->command'
        '*::options:->options'
)

local curcontext="$curcontext" state state_descr line expl
local tmp ret=1

_arguments -s -C : $arguments && return 0

  case "$state" in
    command)
      __display && return 0
      ;;
    options)
      _message "no more options for $words[1]"
      return 1
    ;;
  esac

endsnippet
