# @desc: pretty a log message

function print_help() {
  print::usage "zmsg" "[FLAGS] [TEXT]"
  print::header 12 "OPTIONS"
  print::flag 20 "-h,--origin    " "          Show file/func info"
  print::flag 20 "-f,--file      " "          Show file"
  print::flag 20 "-F,--func      " "          Show function"
  print::flag 20 "-E,--error     " "          Print ERROR message"
  print::flag 20 "-W,--warn      " "          Print WARNING message"
  print::flag 20 "-H,--hint      " "          Print HINT message"
  print::flag 20 "-I,--info      " "          Print INFO message"
  print::flag 20 "-D,--debug     " "          Print DEBUG message"
  print::flag 20 "-T,--trace     " "          Print TRACE message"
  print::flag 20 "-S,--success   " "          Print SUCCESS message"
  print::flag 20 "-n,--nonl      " "          Don't add newline"
  print::flag 20 "-e,--stderr    " "          Print to stderr"
  print::flag 20 "-q,--quiet     " "          Don't print"
  print::flag 20 "-p,--noquiet   " "          Override quiet"
  print::flag 20 "-l,--level     " "[LEVEL]   Specify level [0-5]"
  print::flag 20 "    --help     " "           Show help menu"
    # ERROR: zmsg -hfFE
}

function zmsg() {
    0="${${(M)${0::=${(%):-%x}}:#/*}:-$PWD/$0}"

    builtin emulate -L zsh -o extendedglob
    local -A Opts
    builtin zparseopts -D -E -A Opts -- \
      -origin  h  \
      -file    f  \
      -func    F  \
      -error   E  \
      -warn    W  \
      -hint    H  \
      -info    I  \
      -debug   D  \
      -trace   T  \
      -success S  \
      -nonl    n  \
      -stderr  e  \
      -quiet   q  \
      -noquiet p  \
      -name    N: \
      -level   l: \
      -help || return 7

    (( $+Opts[--help] )) && { print_help; return 0; }

    local cpat="\~config/"; local zpat="\~zsh/"
    local msg level res file

    (( $+Opts[-S] + $+Opts[--success] )) && { msg='SUCCESS' level='l+' }
    (( $+Opts[-T] + $+Opts[--trace]   )) && { msg='TRACE'   level='l0' }
    (( $+Opts[-D] + $+Opts[--debug]   )) && { msg='DEBUG'   level='l1' }
    (( $+Opts[-I] + $+Opts[--info]    )) && { msg='INFO'    level='l2' }
    (( $+Opts[-H] + $+Opts[--hint]    )) && { msg='HINT'    level='l3' }
    (( $+Opts[-W] + $+Opts[--warn]    )) && { msg='WARN'    level='l4' }
    (( $+Opts[-E] + $+Opts[--error]   )) && { msg='ERROR'   level='l5' }

    (($+Opts[-f] + $+Opts[--file])) && file=${${${(D)${${${funcsourcetrace[-1]#_}%:*}:A}}//${~zpat}}//${~cpat}}
    (($+Opts[-F] + $+Opts[--func])) && func=${funcstack[-1]:#zmsg}

    # (($+func)) && func="${func}:${functrace[-1]}"

    [[ -n $msg ]] && res+="%B{pn}[%b{${level:-app}}$msg%B{pn}]%b{%}"
    [[ -n $func ]] && res+="%B{pn}[%b{pre}${func}${file:+:%21F${file}}%B{pn}]%b:{%}"
    [[ -n $msg && -z $func ]] && res+=":"

    # Output origin tag?
    (($+Opts[-h] + $+Opts[--origin])) && builtin set -- $res "$@"
    # Output to stderr?
    (($+Opts[-e] + $+Opts[--stderr])) && local e=-e
    # No new line?
    (($+Opts[-n] + $+Opts[--nonl])) && local n=-n

    # Quiet mode? â†’ no printing if so
    [[ ($+Opts[-q] == 1 || $+Opts[--quiet] == 1 || $1 == 1) \
        && ( $+Opts[-p] != 1 && $+Opts[--noquiet] != 1 ) ]] \
        && return

    xzmsg $e $n "$@"
}

zmsg "$@"

# vim:ft=zsh:sw=4:sts=4:et
