# @desc: shorter way to use zparseopts

# psprint/tig-suite
function @parse-opts() {
  0=${${${(M)${0::=${(%):-%x}}:#/*}:-$PWD/$0}:A}
  builtin emulate -L zsh \
                        -o extendedglob \
                        -o warncreateglobal -o typesetsilent \
                        -o noshortloops -o nopromptsubst \
                        -o rcquotes
  tmp/lib::prune-dashes() {
      # Remove any --/- end option mark
      integer QIDX=${@[(i)(--|-)]}
      ((QIDX<=$#))&&reply=("$@[1,QIDX-1]" "$@[QIDX+1,-1]")||reply=("$@")
  }
  @reset
  local OPTSPEC=$1 ASVAR=$2 ARVAR=$3
  shift 3
  tmp/lib::prune-dashes "$@"
  local -a qe=("$reply[@]")

  local qfopt
  builtin zparseopts \
      -D -F -E ${(s: :)ASVAR:+-A $ASVAR} ${(s: :)ARVAR:+-a $ARVAR} -- \
        ${(s: :)OPTSPEC} || {zerr "invalid options given [${OPTSPEC}]"; return $errnos[(i)EINVAL]; }

  # Save remains without options in reply (pruning --/-)
  tmp/lib::prune-dashes "$@"
  # Get the recognized options
  REPLY="${(j: :)${(@)qe:|reply}}"

  # ( (( ${+opts[-${${(@s. .)@}[1]}]} || ${+opts[--${${(@s. .)@}[2]}]} )) ) && return 0

  return EXIT_SUCCESS
}

# vim: ft=zsh:et:sw=0:ts=2:sts=2:tw=100
