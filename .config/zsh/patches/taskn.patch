diff --git i/Cargo.lock w/Cargo.lock
index 5463e0d..237daf9 100644
--- i/Cargo.lock
+++ w/Cargo.lock
@@ -1,5 +1,7 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
+version = 3
+
 [[package]]
 name = "ansi_term"
 version = "0.11.0"
@@ -44,12 +46,6 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "df8670b8c7b9dae1793364eafadf7239c40d669904660c5960d74cfd80b46a53"
 
-[[package]]
-name = "cc"
-version = "1.0.67"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e3c69b077ad434294d3ce9f1f6143a2a4b89a8a2d54ef813d85003a4fd1137fd"
-
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -152,15 +148,6 @@ version = "0.2.85"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7ccac4b00700875e6a07c6cde370d44d32fa01c5a65cdd2fca6858c479d28bb3"
 
-[[package]]
-name = "malloc_buf"
-version = "0.0.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
-dependencies = [
- "libc",
-]
-
 [[package]]
 name = "num-integer"
 version = "0.1.44"
@@ -186,25 +173,6 @@ version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b8f8bdf33df195859076e54ab11ee78a1b208382d3a26ec40d142ffc1ecc49ef"
 
-[[package]]
-name = "objc"
-version = "0.2.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
-dependencies = [
- "malloc_buf",
- "objc_exception",
-]
-
-[[package]]
-name = "objc_exception"
-version = "0.1.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ad970fb455818ad6cba4c122ad012fae53ae8b4795f86378bce65e4f6bab2ca4"
-dependencies = [
- "cc",
-]
-
 [[package]]
 name = "proc-macro-error"
 version = "1.0.4"
@@ -388,7 +356,6 @@ dependencies = [
  "block",
  "chrono",
  "lazy_static",
- "objc",
  "serde",
  "serde_json",
  "shellexpand",
diff --git i/Cargo.toml w/Cargo.toml
index 20dbeee..f98ba36 100644
--- i/Cargo.toml
+++ w/Cargo.toml
@@ -8,7 +8,6 @@ edition = "2018"
 block = "0.1.6"
 chrono = "0.4.19"
 lazy_static = "1.4.0"
-objc = { version = "0.2.7", features = ["exception"] }
 serde = { version = "1.0.123", features = ["derive"] }
 serde_json = "1.0.61"
 shellexpand = "2.1.0"
diff --git i/src/commands/mod.rs w/src/commands/mod.rs
index 1a867ac..1775ad2 100644
--- i/src/commands/mod.rs
+++ w/src/commands/mod.rs
@@ -1,7 +1,6 @@
 pub mod edit;
 pub mod interactive;
 pub mod order;
-pub mod remind;
 
 use std::io;
 use std::str::FromStr;
@@ -13,7 +12,6 @@ pub enum Command {
     Edit,
     Interactive,
     Order,
-    Remind,
 }
 
 impl Command {
@@ -23,7 +21,6 @@ impl Command {
             Edit => edit::execute(opt),
             Interactive => interactive::execute(opt),
             Order => order::execute(opt),
-            Remind => remind::execute(opt),
         }
     }
 }
@@ -37,7 +34,6 @@ impl FromStr for Command {
             "edit" => Ok(Edit),
             "interactive" => Ok(Interactive),
             "order" => Ok(Order),
-            "remind" => Ok(Remind),
             _ => Err(format!("failed to parse Command from '{}'", s)),
         }
     }
diff --git i/src/commands/remind/eventkit.rs w/src/commands/remind/eventkit.rs
deleted file mode 100644
index 3413695..0000000
--- i/src/commands/remind/eventkit.rs
+++ /dev/null
@@ -1,393 +0,0 @@
-//! Provides a high-level wrapper around the eventkit-sys crate defined in this repository.
-//! This module allows one to read, create, and update reminders on macOS.
-//! Because this module depends on eventkit-sys, do not expect it to compile on non-macOS systems.
-use std::ffi::{c_void, CString};
-use std::os::raw::c_char;
-use std::ptr::null_mut;
-use std::slice;
-use std::str;
-use std::sync::{Arc, Condvar, Mutex};
-
-use block::ConcreteBlock;
-use chrono::{DateTime, Datelike, TimeZone, Timelike};
-use objc::runtime::Object;
-use objc::{class, msg_send, sel, sel_impl};
-
-// NOTE:
-//   - calendarItemWithIdentifier to get a reminder
-//   - requires a UUID from the reminder
-//   - do we have the UUID after we save a reminder?
-
-#[link(name = "EventKit", kind = "framework")]
-extern "C" {}
-
-#[derive(Clone, Debug)]
-pub enum EKError {
-    /// Used when an operation requires some kind of permissions that the user has not provided.
-    NoAccess,
-
-    /// General case whenever an NSError is encountered. The String is populated by the NSError's
-    /// localizedDescription.
-    NSError(String),
-
-    /// Used when an operation attempts to retrieve a value that may not be present.
-    NotFound,
-}
-
-impl EKError {
-    /// The caller of this function must ensure that the *mut Object provided is, in fact, an
-    /// NSError nad not some other kind of Object.
-    unsafe fn from_ns_error(ns_error: *mut Object) -> EKError {
-        let ns_desc = msg_send![ns_error, localizedDescription];
-        let desc = from_ns_string(ns_desc);
-        EKError::NSError(desc)
-    }
-}
-
-pub type EKResult<T> = Result<T, EKError>;
-
-pub struct EventStore {
-    ek_event_store: *mut Object,
-}
-
-impl EventStore {
-    pub fn new() -> EKResult<Self> {
-        let cls = class!(EKEventStore);
-        let mut ek_event_store: *mut Object;
-        unsafe {
-            ek_event_store = msg_send![cls, alloc];
-            ek_event_store = msg_send![ek_event_store, init];
-        }
-
-        Ok(Self { ek_event_store })
-    }
-
-    pub fn new_with_permission() -> EKResult<Self> {
-        let mut event_store = Self::new()?;
-        event_store.request_permission()?;
-        Ok(event_store)
-    }
-
-    pub fn request_permission(&mut self) -> EKResult<()> {
-        let has_permission = Arc::new(Mutex::new(Ok(false)));
-        let has_permission_cond = Arc::new(Condvar::new());
-        let completion_block;
-        {
-            let has_permission = has_permission.clone();
-            let has_permission_cond = has_permission_cond.clone();
-            completion_block = ConcreteBlock::new(move |granted: bool, ns_error: *mut Object| {
-                let mut lock = has_permission.lock().unwrap();
-                if ns_error != null_mut() {
-                    unsafe {
-                        *lock = Err(EKError::from_ns_error(ns_error));
-                    }
-                } else {
-                    *lock = Ok(granted);
-                }
-                has_permission_cond.notify_one();
-            })
-            .copy();
-        }
-
-        let lock = has_permission.lock().unwrap();
-        unsafe {
-            let _: c_void = msg_send![
-                self.ek_event_store,
-                requestAccessToEntityType:EKEntityType::Reminder
-                completion:completion_block
-            ];
-        }
-        let lock = has_permission_cond.wait(lock).unwrap();
-
-        match &*lock {
-            Err(e) => Err(e.clone()),
-            Ok(granted) => {
-                if !granted {
-                    Err(EKError::NoAccess)
-                } else {
-                    Ok(())
-                }
-            }
-        }
-    }
-
-    pub fn save_reminder(&mut self, reminder: &Reminder, commit: bool) -> EKResult<bool> {
-        let mut ns_error: *mut Object = null_mut();
-        let saved: bool;
-        unsafe {
-            saved = msg_send![
-                self.ek_event_store,
-                saveReminder:reminder.ek_reminder
-                commit:commit
-                error:&mut (ns_error) as *mut *mut Object
-            ];
-        }
-
-        if ns_error != null_mut() {
-            unsafe { return Err(EKError::from_ns_error(ns_error)) }
-        }
-
-        Ok(saved)
-    }
-
-    pub fn get_reminder<S: AsRef<str>>(&mut self, uuid: S) -> EKResult<Reminder> {
-        let ns_string = to_ns_string(uuid.as_ref().to_string());
-        let ek_reminder: *mut Object;
-        unsafe {
-            ek_reminder = msg_send![self.ek_event_store, calendarItemWithIdentifier: ns_string];
-            let _: *mut Object = msg_send![ns_string, release];
-        }
-
-        if ek_reminder == null_mut() {
-            Err(EKError::NotFound)
-        } else {
-            Ok(Reminder { ek_reminder })
-        }
-    }
-}
-
-impl Drop for EventStore {
-    fn drop(&mut self) {
-        unsafe {
-            let _: c_void = msg_send![self.ek_event_store, release];
-        }
-    }
-}
-
-pub struct Reminder {
-    ek_reminder: *mut Object,
-}
-
-impl Reminder {
-    pub fn new(event_store: &mut EventStore) -> Self {
-        let cls = class!(EKReminder);
-        let ek_reminder: *mut Object;
-        unsafe {
-            ek_reminder = msg_send![cls, reminderWithEventStore:event_store.ek_event_store];
-        }
-
-        let cal: *mut Object;
-        unsafe {
-            cal = msg_send![event_store.ek_event_store, defaultCalendarForNewReminders];
-            let _: c_void = msg_send![ek_reminder, setCalendar: cal];
-        }
-
-        Self { ek_reminder }
-    }
-
-    pub fn uuid(&self) -> String {
-        let ns_string: *mut Object;
-        unsafe {
-            ns_string = msg_send![self.ek_reminder, calendarItemIdentifier];
-            from_ns_string(ns_string)
-        }
-    }
-
-    // TODO: this part is probably dangerous + leaks memory. come back here at some point and clean
-    // it up.
-    pub fn set_title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
-        let ns_string = to_ns_string(title.as_ref().to_string());
-        unsafe {
-            let _: c_void = msg_send![self.ek_reminder, setTitle: ns_string];
-        }
-        self
-    }
-
-    pub fn set_notes<S: AsRef<str>>(&mut self, notes: S) -> &mut Self {
-        let ns_string = to_ns_string(notes.as_ref().to_string());
-        unsafe {
-            let _: c_void = msg_send![self.ek_reminder, setNotes: ns_string];
-        }
-        self
-    }
-
-    pub fn set_alarm<Tz: TimeZone>(&mut self, date_time: Option<DateTime<Tz>>) -> &mut Self {
-        if let Some(date_time) = date_time {
-            let ns_date_components = to_ns_date_components(date_time);
-            unsafe {
-                let _: c_void =
-                    msg_send![self.ek_reminder, setDueDateComponents: ns_date_components];
-                let _: c_void = msg_send![ns_date_components, release];
-            }
-        } else {
-            let nil: *mut Object = null_mut();
-            unsafe {
-                let _: c_void = msg_send![self.ek_reminder, setDueDateComponents: nil];
-            }
-        }
-        self
-    }
-}
-
-impl Drop for Reminder {
-    fn drop(&mut self) {
-        unsafe {
-            let ns_title: *mut Object = msg_send![self.ek_reminder, title];
-            let _: c_void = msg_send![ns_title, release];
-
-            let ns_notes: *mut Object = msg_send![self.ek_reminder, notes];
-            let _: c_void = msg_send![ns_notes, release];
-
-            let _: c_void = msg_send![self.ek_reminder, release];
-        }
-    }
-}
-
-/// This is defined in Objective C to be:
-///
-/// ```
-/// enum {
-///    EKEntityTypeEvent,
-///    EKEntityTypeReminder
-/// };
-/// typedef NSUInteger EKEntityType;
-/// ```
-///
-/// So we just use a similar enum structure here.
-#[repr(u64)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-enum EKEntityType {
-    // we don't actually use the Event type ever
-    // Event = 0,
-    Reminder = 1,
-}
-
-/// Converts a str-like to an
-/// [NSString](https://developer.apple.com/documentation/foundation/nsstring?language=objc)
-/// returning it as a `*mut Object`. It is the responsibility of the caller to free this string.
-///
-/// # Arguments
-///
-/// * `s` - The string we want to convert to an NSString. This can be owned or unowned.
-fn to_ns_string<S: AsRef<str>>(s: S) -> *mut Object {
-    let c_string = CString::new(s.as_ref()).unwrap().into_raw();
-
-    let cls = class!(NSString);
-    let mut ns_string: *mut Object;
-    unsafe {
-        ns_string = msg_send![cls, alloc];
-        ns_string = msg_send![ns_string, initWithUTF8String: c_string];
-    }
-
-    unsafe {
-        let _ = CString::from_raw(c_string);
-    }
-
-    ns_string
-}
-
-/// Converts an [NSString](https://developer.apple.com/documentation/foundation/nsstring?language=objc)
-/// into a [String].
-///
-/// The provided NSString MUST be UTF8 encoded. This function copies from the NSString, and does
-/// not attempt to release it.
-unsafe fn from_ns_string(ns_string: *mut Object) -> String {
-    let bytes = {
-        let bytes: *const c_char = msg_send![ns_string, UTF8String];
-        bytes as *const u8
-    };
-    let len: usize = msg_send![ns_string, lengthOfBytesUsingEncoding:4]; // 4 = UTF8_ENCODING
-    let bytes = slice::from_raw_parts(bytes, len);
-    str::from_utf8(bytes).unwrap().to_string()
-}
-
-/// Converts a [DateTime] of a particular TZ into its
-/// [NSDateComponents](https://developer.apple.com/documentation/foundation/nsdatecomponents?language=objc)
-/// counterpart.
-///
-/// # Arguments
-///
-/// * `date_time` - The datetime we want to convert.
-fn to_ns_date_components<Tz: TimeZone>(date_time: DateTime<Tz>) -> *mut Object {
-    let mut ns_date_components: *mut Object;
-    unsafe {
-        ns_date_components = msg_send![class!(NSDateComponents), alloc];
-        ns_date_components = msg_send![ns_date_components, init];
-
-        let _: c_void = msg_send![ns_date_components, setYear:date_time.year()];
-        let _: c_void = msg_send![ns_date_components, setMonth:date_time.month()];
-        let _: c_void = msg_send![ns_date_components, setDay:date_time.day()];
-        let _: c_void = msg_send![ns_date_components, setHour:date_time.hour()];
-        let _: c_void = msg_send![ns_date_components, setMinute:date_time.minute()];
-        let _: c_void = msg_send![ns_date_components, setSecond:date_time.second()];
-    }
-    ns_date_components
-}
-
-#[cfg(test)]
-mod tests {
-    use std::sync::Mutex;
-
-    use chrono::{Local, NaiveDate};
-    use lazy_static::lazy_static;
-
-    use super::*;
-
-    // each test must exclusively own the EventStore
-    // so we make sure only one executes at a time.
-    lazy_static! {
-        static ref MTX: Mutex<()> = Mutex::new(());
-    }
-
-    #[test]
-    fn test_event_store_new() {
-        let _lock = MTX.lock().unwrap();
-        let _ = EventStore::new();
-    }
-
-    #[test]
-    fn test_event_store_new_with_permission() {
-        let _lock = MTX.lock().unwrap();
-        let _ = EventStore::new_with_permission();
-    }
-
-    #[test]
-    fn test_to_ns_string() {
-        let ns_string: *mut Object;
-        unsafe {
-            ns_string = to_ns_string("hello world");
-            let _: c_void = msg_send![ns_string, release];
-        }
-    }
-
-    #[test]
-    fn test_from_ns_string() {
-        let s1 = "hello world".to_string();
-        let ns_string = to_ns_string(&s1);
-        let s2;
-        unsafe {
-            s2 = from_ns_string(ns_string);
-            let _: c_void = msg_send![ns_string, release];
-        }
-        assert_eq!(s1, s2);
-    }
-
-    #[test]
-    fn test_reminder_new() -> EKResult<()> {
-        let _lock = MTX.lock().unwrap();
-        let mut event_store = EventStore::new()?;
-        let _ = Reminder::new(&mut event_store)
-            .set_title("a title")
-            .set_notes("a notes")
-            .set_alarm(Some(Local.from_utc_datetime(
-                &NaiveDate::from_ymd(2021, 5, 01).and_hms(12, 0, 0),
-            )));
-        Ok(())
-    }
-
-    #[test]
-    fn test_save_reminder() -> EKResult<()> {
-        let _lock = MTX.lock().unwrap();
-        let mut event_store = EventStore::new()?;
-        let mut reminder = Reminder::new(&mut event_store);
-        reminder
-            .set_title("a title")
-            .set_notes("a notes")
-            .set_alarm(Some(Local.from_utc_datetime(
-                &NaiveDate::from_ymd(2021, 5, 01).and_hms(12, 0, 0),
-            )));
-        let saved = event_store.save_reminder(&reminder, true)?;
-        assert!(saved);
-        Ok(())
-    }
-}
diff --git i/src/commands/remind/mod.rs w/src/commands/remind/mod.rs
deleted file mode 100644
index 684255d..0000000
--- i/src/commands/remind/mod.rs
+++ /dev/null
@@ -1,39 +0,0 @@
-mod eventkit;
-
-use std::io;
-
-use crate::opt::Opt;
-use crate::taskwarrior::Task;
-use eventkit::{EventStore, Reminder};
-
-pub fn execute(opt: Opt) -> io::Result<()> {
-    let mut taskwarrior_args = opt.args;
-    taskwarrior_args.push("+remindme".to_string());
-    taskwarrior_args.push("(status:pending or status:waiting)".to_string());
-    let mut tasks = Task::get(taskwarrior_args.into_iter())?;
-    let task_len = tasks.len();
-
-    Task::define_reminder_uda()?;
-
-    let mut event_store = EventStore::new_with_permission().unwrap();
-    for (i, task) in tasks.iter_mut().enumerate() {
-        let mut reminder;
-        if let Some(taskn_reminder_uuid) = &task.taskn_reminder_uuid {
-            reminder = event_store.get_reminder(taskn_reminder_uuid).unwrap();
-        } else {
-            reminder = Reminder::new(&mut event_store);
-        }
-
-        reminder
-            .set_title(&task.description)
-            .set_notes(&task.uuid)
-            .set_alarm(task.wait.clone().map(|pdt| pdt.0));
-
-        event_store
-            .save_reminder(&reminder, i == task_len - 1)
-            .unwrap();
-        task.set_reminder_uuid(reminder.uuid())?;
-    }
-
-    Ok(())
-}
